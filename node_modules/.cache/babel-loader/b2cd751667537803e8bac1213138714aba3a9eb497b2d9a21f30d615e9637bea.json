{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst Refractor = /* @__PURE__ */(() => {\n  const _Refractor = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isRefractor = true;\n      this.type = \"Refractor\";\n      this.camera = new PerspectiveCamera();\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _Refractor.RefractorShader;\n      const multisample = options.multisample !== void 0 ? options.multisample : 4;\n      const virtualCamera = this.camera;\n      virtualCamera.matrixAutoUpdate = false;\n      virtualCamera.userData.refractor = true;\n      const refractorPlane = new Plane();\n      const textureMatrix = new Matrix4();\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n        samples: multisample,\n        type: HalfFloatType\n      });\n      this.material = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        transparent: true\n        // ensures, refractors are drawn from farthest to closest\n      });\n      this.material.uniforms[\"color\"].value = color;\n      this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      const visible = function () {\n        const refractorWorldPosition = new Vector3();\n        const cameraWorldPosition = new Vector3();\n        const rotationMatrix = new Matrix4();\n        const view = new Vector3();\n        const normal = new Vector3();\n        return function visible2(camera) {\n          refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n          cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n          view.subVectors(refractorWorldPosition, cameraWorldPosition);\n          rotationMatrix.extractRotation(scope.matrixWorld);\n          normal.set(0, 0, 1);\n          normal.applyMatrix4(rotationMatrix);\n          return view.dot(normal) < 0;\n        };\n      }();\n      const updateRefractorPlane = function () {\n        const normal = new Vector3();\n        const position = new Vector3();\n        const quaternion = new Quaternion();\n        const scale = new Vector3();\n        return function updateRefractorPlane2() {\n          scope.matrixWorld.decompose(position, quaternion, scale);\n          normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n          normal.negate();\n          refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n        };\n      }();\n      const updateVirtualCamera = function () {\n        const clipPlane = new Plane();\n        const clipVector = new Vector4();\n        const q = new Vector4();\n        return function updateVirtualCamera2(camera) {\n          virtualCamera.matrixWorld.copy(camera.matrixWorld);\n          virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n          virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n          virtualCamera.far = camera.far;\n          clipPlane.copy(refractorPlane);\n          clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n          clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n          const projectionMatrix = virtualCamera.projectionMatrix;\n          q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n          q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n          q.z = -1;\n          q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n          clipVector.multiplyScalar(2 / clipVector.dot(q));\n          projectionMatrix.elements[2] = clipVector.x;\n          projectionMatrix.elements[6] = clipVector.y;\n          projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n          projectionMatrix.elements[14] = clipVector.w;\n        };\n      }();\n      function updateTextureMatrix(camera) {\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(camera.projectionMatrix);\n        textureMatrix.multiply(camera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n      }\n      function render(renderer, scene, camera) {\n        scope.visible = false;\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentToneMapping = renderer.toneMapping;\n        let isSRGB = false;\n        if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.outputEncoding = 3e3;\n        renderer.toneMapping = NoToneMapping;\n        renderer.setRenderTarget(renderTarget);\n        if (renderer.autoClear === false) renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.toneMapping = currentToneMapping;\n        renderer.setRenderTarget(currentRenderTarget);\n        if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n        scope.visible = true;\n      }\n      this.onBeforeRender = function (renderer, scene, camera) {\n        if (camera.userData.refractor === true) return;\n        if (!visible(camera) === true) return;\n        updateRefractorPlane();\n        updateTextureMatrix(camera);\n        updateVirtualCamera(camera);\n        render(renderer, scene, camera);\n      };\n      this.getRenderTarget = function () {\n        return renderTarget;\n      };\n      this.dispose = function () {\n        renderTarget.dispose();\n        scope.material.dispose();\n      };\n    }\n  };\n  let Refractor2 = _Refractor;\n  __publicField(Refractor2, \"RefractorShader\", {\n    uniforms: {\n      color: {\n        value: null\n      },\n      tDiffuse: {\n        value: null\n      },\n      textureMatrix: {\n        value: null\n      }\n    },\n    vertexShader: (/* glsl */\n    `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`),\n    fragmentShader: (/* glsl */\n    `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n\n\t\t}`)\n  });\n  return Refractor2;\n})();\nexport { Refractor };\n//# sourceMappingURL=Refractor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}