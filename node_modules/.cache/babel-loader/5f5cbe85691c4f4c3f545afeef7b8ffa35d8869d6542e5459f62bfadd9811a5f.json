{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { DepthTexture, DepthStencilFormat, UnsignedInt248Type, WebGLRenderTarget, NearestFilter, ShaderMaterial, UniformsUtils, NoBlending, MeshNormalMaterial, DstColorFactor, ZeroFactor, AddEquation, DstAlphaFactor, Color, CustomBlending, Vector3, MathUtils, DataTexture, RedFormat, FloatType, RepeatWrapping } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nimport { SSAOShader, SSAOBlurShader, SSAODepthShader } from \"../shaders/SSAOShader.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nconst SSAOPass = /* @__PURE__ */(() => {\n  const _SSAOPass = class extends Pass {\n    constructor(scene, camera, width, height) {\n      super();\n      this.width = width !== void 0 ? width : 512;\n      this.height = height !== void 0 ? height : 512;\n      this.clear = true;\n      this.camera = camera;\n      this.scene = scene;\n      this.kernelRadius = 8;\n      this.kernelSize = 32;\n      this.kernel = [];\n      this.noiseTexture = null;\n      this.output = 0;\n      this.minDistance = 5e-3;\n      this.maxDistance = 0.1;\n      this._visibilityCache = /* @__PURE__ */new Map();\n      this.generateSampleKernel();\n      this.generateRandomKernelRotations();\n      const depthTexture = new DepthTexture();\n      depthTexture.format = DepthStencilFormat;\n      depthTexture.type = UnsignedInt248Type;\n      this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height);\n      this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        depthTexture\n      });\n      this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);\n      this.blurRenderTarget = this.ssaoRenderTarget.clone();\n      if (SSAOShader === void 0) {\n        console.error(\"THREE.SSAOPass: The pass relies on SSAOShader.\");\n      }\n      this.ssaoMaterial = new ShaderMaterial({\n        defines: Object.assign({}, SSAOShader.defines),\n        uniforms: UniformsUtils.clone(SSAOShader.uniforms),\n        vertexShader: SSAOShader.vertexShader,\n        fragmentShader: SSAOShader.fragmentShader,\n        blending: NoBlending\n      });\n      this.ssaoMaterial.uniforms[\"tDiffuse\"].value = this.beautyRenderTarget.texture;\n      this.ssaoMaterial.uniforms[\"tNormal\"].value = this.normalRenderTarget.texture;\n      this.ssaoMaterial.uniforms[\"tDepth\"].value = this.normalRenderTarget.depthTexture;\n      this.ssaoMaterial.uniforms[\"tNoise\"].value = this.noiseTexture;\n      this.ssaoMaterial.uniforms[\"kernel\"].value = this.kernel;\n      this.ssaoMaterial.uniforms[\"cameraNear\"].value = this.camera.near;\n      this.ssaoMaterial.uniforms[\"cameraFar\"].value = this.camera.far;\n      this.ssaoMaterial.uniforms[\"resolution\"].value.set(this.width, this.height);\n      this.ssaoMaterial.uniforms[\"cameraProjectionMatrix\"].value.copy(this.camera.projectionMatrix);\n      this.ssaoMaterial.uniforms[\"cameraInverseProjectionMatrix\"].value.copy(this.camera.projectionMatrixInverse);\n      this.normalMaterial = new MeshNormalMaterial();\n      this.normalMaterial.blending = NoBlending;\n      this.blurMaterial = new ShaderMaterial({\n        defines: Object.assign({}, SSAOBlurShader.defines),\n        uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),\n        vertexShader: SSAOBlurShader.vertexShader,\n        fragmentShader: SSAOBlurShader.fragmentShader\n      });\n      this.blurMaterial.uniforms[\"tDiffuse\"].value = this.ssaoRenderTarget.texture;\n      this.blurMaterial.uniforms[\"resolution\"].value.set(this.width, this.height);\n      this.depthRenderMaterial = new ShaderMaterial({\n        defines: Object.assign({}, SSAODepthShader.defines),\n        uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),\n        vertexShader: SSAODepthShader.vertexShader,\n        fragmentShader: SSAODepthShader.fragmentShader,\n        blending: NoBlending\n      });\n      this.depthRenderMaterial.uniforms[\"tDepth\"].value = this.normalRenderTarget.depthTexture;\n      this.depthRenderMaterial.uniforms[\"cameraNear\"].value = this.camera.near;\n      this.depthRenderMaterial.uniforms[\"cameraFar\"].value = this.camera.far;\n      this.copyMaterial = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(CopyShader.uniforms),\n        vertexShader: CopyShader.vertexShader,\n        fragmentShader: CopyShader.fragmentShader,\n        transparent: true,\n        depthTest: false,\n        depthWrite: false,\n        blendSrc: DstColorFactor,\n        blendDst: ZeroFactor,\n        blendEquation: AddEquation,\n        blendSrcAlpha: DstAlphaFactor,\n        blendDstAlpha: ZeroFactor,\n        blendEquationAlpha: AddEquation\n      });\n      this.fsQuad = new FullScreenQuad(null);\n      this.originalClearColor = new Color();\n    }\n    dispose() {\n      this.beautyRenderTarget.dispose();\n      this.normalRenderTarget.dispose();\n      this.ssaoRenderTarget.dispose();\n      this.blurRenderTarget.dispose();\n      this.normalMaterial.dispose();\n      this.blurMaterial.dispose();\n      this.copyMaterial.dispose();\n      this.depthRenderMaterial.dispose();\n      this.fsQuad.dispose();\n    }\n    render(renderer, writeBuffer) {\n      renderer.setRenderTarget(this.beautyRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      this.overrideVisibility();\n      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);\n      this.restoreVisibility();\n      this.ssaoMaterial.uniforms[\"kernelRadius\"].value = this.kernelRadius;\n      this.ssaoMaterial.uniforms[\"minDistance\"].value = this.minDistance;\n      this.ssaoMaterial.uniforms[\"maxDistance\"].value = this.maxDistance;\n      this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);\n      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);\n      switch (this.output) {\n        case _SSAOPass.OUTPUT.SSAO:\n          this.copyMaterial.uniforms[\"tDiffuse\"].value = this.ssaoRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          break;\n        case _SSAOPass.OUTPUT.Blur:\n          this.copyMaterial.uniforms[\"tDiffuse\"].value = this.blurRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          break;\n        case _SSAOPass.OUTPUT.Beauty:\n          this.copyMaterial.uniforms[\"tDiffuse\"].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          break;\n        case _SSAOPass.OUTPUT.Depth:\n          this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);\n          break;\n        case _SSAOPass.OUTPUT.Normal:\n          this.copyMaterial.uniforms[\"tDiffuse\"].value = this.normalRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          break;\n        case _SSAOPass.OUTPUT.Default:\n          this.copyMaterial.uniforms[\"tDiffuse\"].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          this.copyMaterial.uniforms[\"tDiffuse\"].value = this.blurRenderTarget.texture;\n          this.copyMaterial.blending = CustomBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          break;\n        default:\n          console.warn(\"THREE.SSAOPass: Unknown output type.\");\n      }\n    }\n    renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n      renderer.getClearColor(this.originalClearColor);\n      const originalClearAlpha = renderer.getClearAlpha();\n      const originalAutoClear = renderer.autoClear;\n      renderer.setRenderTarget(renderTarget);\n      renderer.autoClear = false;\n      if (clearColor !== void 0 && clearColor !== null) {\n        renderer.setClearColor(clearColor);\n        renderer.setClearAlpha(clearAlpha || 0);\n        renderer.clear();\n      }\n      this.fsQuad.material = passMaterial;\n      this.fsQuad.render(renderer);\n      renderer.autoClear = originalAutoClear;\n      renderer.setClearColor(this.originalClearColor);\n      renderer.setClearAlpha(originalClearAlpha);\n    }\n    renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n      renderer.getClearColor(this.originalClearColor);\n      const originalClearAlpha = renderer.getClearAlpha();\n      const originalAutoClear = renderer.autoClear;\n      renderer.setRenderTarget(renderTarget);\n      renderer.autoClear = false;\n      clearColor = overrideMaterial.clearColor || clearColor;\n      clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n      if (clearColor !== void 0 && clearColor !== null) {\n        renderer.setClearColor(clearColor);\n        renderer.setClearAlpha(clearAlpha || 0);\n        renderer.clear();\n      }\n      this.scene.overrideMaterial = overrideMaterial;\n      renderer.render(this.scene, this.camera);\n      this.scene.overrideMaterial = null;\n      renderer.autoClear = originalAutoClear;\n      renderer.setClearColor(this.originalClearColor);\n      renderer.setClearAlpha(originalClearAlpha);\n    }\n    setSize(width, height) {\n      this.width = width;\n      this.height = height;\n      this.beautyRenderTarget.setSize(width, height);\n      this.ssaoRenderTarget.setSize(width, height);\n      this.normalRenderTarget.setSize(width, height);\n      this.blurRenderTarget.setSize(width, height);\n      this.ssaoMaterial.uniforms[\"resolution\"].value.set(width, height);\n      this.ssaoMaterial.uniforms[\"cameraProjectionMatrix\"].value.copy(this.camera.projectionMatrix);\n      this.ssaoMaterial.uniforms[\"cameraInverseProjectionMatrix\"].value.copy(this.camera.projectionMatrixInverse);\n      this.blurMaterial.uniforms[\"resolution\"].value.set(width, height);\n    }\n    generateSampleKernel() {\n      const kernelSize = this.kernelSize;\n      const kernel = this.kernel;\n      for (let i = 0; i < kernelSize; i++) {\n        const sample = new Vector3();\n        sample.x = Math.random() * 2 - 1;\n        sample.y = Math.random() * 2 - 1;\n        sample.z = Math.random();\n        sample.normalize();\n        let scale = i / kernelSize;\n        scale = MathUtils.lerp(0.1, 1, scale * scale);\n        sample.multiplyScalar(scale);\n        kernel.push(sample);\n      }\n    }\n    generateRandomKernelRotations() {\n      const width = 4,\n        height = 4;\n      if (SimplexNoise === void 0) {\n        console.error(\"THREE.SSAOPass: The pass relies on SimplexNoise.\");\n      }\n      const simplex = new SimplexNoise();\n      const size = width * height;\n      const data = new Float32Array(size);\n      for (let i = 0; i < size; i++) {\n        const x = Math.random() * 2 - 1;\n        const y = Math.random() * 2 - 1;\n        const z = 0;\n        data[i] = simplex.noise3d(x, y, z);\n      }\n      this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);\n      this.noiseTexture.wrapS = RepeatWrapping;\n      this.noiseTexture.wrapT = RepeatWrapping;\n      this.noiseTexture.needsUpdate = true;\n    }\n    overrideVisibility() {\n      const scene = this.scene;\n      const cache = this._visibilityCache;\n      scene.traverse(function (object) {\n        cache.set(object, object.visible);\n        if (object.isPoints || object.isLine) object.visible = false;\n      });\n    }\n    restoreVisibility() {\n      const scene = this.scene;\n      const cache = this._visibilityCache;\n      scene.traverse(function (object) {\n        const visible = cache.get(object);\n        object.visible = visible;\n      });\n      cache.clear();\n    }\n  };\n  let SSAOPass2 = _SSAOPass;\n  __publicField(SSAOPass2, \"OUTPUT\", {\n    Default: 0,\n    SSAO: 1,\n    Blur: 2,\n    Beauty: 3,\n    Depth: 4,\n    Normal: 5\n  });\n  return SSAOPass2;\n})();\nexport { SSAOPass };\n//# sourceMappingURL=SSAOPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}