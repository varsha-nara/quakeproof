{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Mesh, Points } from \"three\";\nconst DRACOExporter = /* @__PURE__ */(() => {\n  const _DRACOExporter = class {\n    parse(object, options = {\n      decodeSpeed: 5,\n      encodeSpeed: 5,\n      encoderMethod: _DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n      quantization: [16, 8, 8, 8, 8],\n      exportUvs: true,\n      exportNormals: true,\n      exportColor: false\n    }) {\n      if (object instanceof BufferGeometry && object.isBufferGeometry) {\n        throw new Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");\n      }\n      if (DracoEncoderModule === void 0) {\n        throw new Error(\"THREE.DRACOExporter: required the draco_encoder to work.\");\n      }\n      const geometry = object.geometry;\n      const dracoEncoder = DracoEncoderModule();\n      const encoder = new dracoEncoder.Encoder();\n      let builder;\n      let dracoObject;\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\");\n      }\n      if (object instanceof Mesh && object.isMesh) {\n        builder = new dracoEncoder.MeshBuilder();\n        dracoObject = new dracoEncoder.Mesh();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n        const faces = geometry.getIndex();\n        if (faces !== null) {\n          builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n        } else {\n          const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n          for (let i = 0; i < faces2.length; i++) {\n            faces2[i] = i;\n          }\n          builder.AddFacesToMesh(dracoObject, vertices.count, faces2);\n        }\n        if (options.exportNormals) {\n          const normals = geometry.getAttribute(\"normal\");\n          if (normals !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n          }\n        }\n        if (options.exportUvs) {\n          const uvs = geometry.getAttribute(\"uv\");\n          if (uvs !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n          }\n        }\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n          }\n        }\n      } else if (object instanceof Points && object.isPoints) {\n        builder = new dracoEncoder.PointCloudBuilder();\n        dracoObject = new dracoEncoder.PointCloud();\n        const vertices = geometry.getAttribute(\"position\");\n        builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n        if (options.exportColor) {\n          const colors = geometry.getAttribute(\"color\");\n          if (colors !== void 0) {\n            builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n          }\n        }\n      } else {\n        throw new Error(\"DRACOExporter: Unsupported object type.\");\n      }\n      const encodedData = new dracoEncoder.DracoInt8Array();\n      const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;\n      const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;\n      encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);\n      if (options.encoderMethod !== void 0) {\n        encoder.SetEncodingMethod(options.encoderMethod);\n      }\n      if (options.quantization !== void 0) {\n        for (let i = 0; i < 5; i++) {\n          if (options.quantization[i] !== void 0) {\n            encoder.SetAttributeQuantization(i, options.quantization[i]);\n          }\n        }\n      }\n      let length;\n      if (object instanceof Mesh && object.isMesh) {\n        length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n      } else {\n        length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n      }\n      dracoEncoder.destroy(dracoObject);\n      if (length === 0) {\n        throw new Error(\"THREE.DRACOExporter: Draco encoding failed.\");\n      }\n      const outputData = new Int8Array(new ArrayBuffer(length));\n      for (let i = 0; i < length; i++) {\n        outputData[i] = encodedData.GetValue(i);\n      }\n      dracoEncoder.destroy(encodedData);\n      dracoEncoder.destroy(encoder);\n      dracoEncoder.destroy(builder);\n      return outputData;\n    }\n  };\n  let DRACOExporter2 = _DRACOExporter;\n  // Encoder methods\n  __publicField(DRACOExporter2, \"MESH_EDGEBREAKER_ENCODING\", 1);\n  __publicField(DRACOExporter2, \"MESH_SEQUENTIAL_ENCODING\", 0);\n  // Geometry type\n  __publicField(DRACOExporter2, \"POINT_CLOUD\", 0);\n  __publicField(DRACOExporter2, \"TRIANGULAR_MESH\", 1);\n  // Attribute type\n  __publicField(DRACOExporter2, \"INVALID\", -1);\n  __publicField(DRACOExporter2, \"POSITION\", 0);\n  __publicField(DRACOExporter2, \"NORMAL\", 1);\n  __publicField(DRACOExporter2, \"COLOR\", 2);\n  __publicField(DRACOExporter2, \"TEX_COORD\", 3);\n  __publicField(DRACOExporter2, \"GENERIC\", 4);\n  return DRACOExporter2;\n})();\nexport { DRACOExporter };\n//# sourceMappingURL=DRACOExporter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}