{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Color, Vector2, WebGLRenderTarget, HalfFloatType, NearestFilter, DepthTexture, UnsignedShortType, MeshDepthMaterial, RGBADepthPacking, NoBlending, MeshNormalMaterial, ShaderMaterial, UniformsUtils, CustomBlending, DstColorFactor, ZeroFactor, AddEquation, DstAlphaFactor } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { SAOShader } from \"../shaders/SAOShader.js\";\nimport { DepthLimitedBlurShader, BlurShaderUtils } from \"../shaders/DepthLimitedBlurShader.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { UnpackDepthRGBAShader } from \"../shaders/UnpackDepthRGBAShader.js\";\nconst SAOPass = /* @__PURE__ */(() => {\n  class SAOPass2 extends Pass {\n    constructor(scene, camera, useDepthTexture = false, useNormals = false, resolution = new Vector2(256, 256)) {\n      super();\n      this.scene = scene;\n      this.camera = camera;\n      this.clear = true;\n      this.needsSwap = false;\n      this.supportsDepthTextureExtension = useDepthTexture;\n      this.supportsNormalTexture = useNormals;\n      this.originalClearColor = new Color();\n      this._oldClearColor = new Color();\n      this.oldClearAlpha = 1;\n      this.params = {\n        output: 0,\n        saoBias: 0.5,\n        saoIntensity: 0.18,\n        saoScale: 1,\n        saoKernelRadius: 100,\n        saoMinResolution: 0,\n        saoBlur: true,\n        saoBlurRadius: 8,\n        saoBlurStdDev: 4,\n        saoBlurDepthCutoff: 0.01\n      };\n      this.resolution = new Vector2(resolution.x, resolution.y);\n      this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n        type: HalfFloatType\n      });\n      this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();\n      this.beautyRenderTarget = this.saoRenderTarget.clone();\n      this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        type: HalfFloatType\n      });\n      this.depthRenderTarget = this.normalRenderTarget.clone();\n      let depthTexture;\n      if (this.supportsDepthTextureExtension) {\n        depthTexture = new DepthTexture();\n        depthTexture.type = UnsignedShortType;\n        this.beautyRenderTarget.depthTexture = depthTexture;\n        this.beautyRenderTarget.depthBuffer = true;\n      }\n      this.depthMaterial = new MeshDepthMaterial();\n      this.depthMaterial.depthPacking = RGBADepthPacking;\n      this.depthMaterial.blending = NoBlending;\n      this.normalMaterial = new MeshNormalMaterial();\n      this.normalMaterial.blending = NoBlending;\n      this.saoMaterial = new ShaderMaterial({\n        defines: Object.assign({}, SAOShader.defines),\n        fragmentShader: SAOShader.fragmentShader,\n        vertexShader: SAOShader.vertexShader,\n        uniforms: UniformsUtils.clone(SAOShader.uniforms)\n      });\n      this.saoMaterial.extensions.derivatives = true;\n      this.saoMaterial.defines[\"DEPTH_PACKING\"] = this.supportsDepthTextureExtension ? 0 : 1;\n      this.saoMaterial.defines[\"NORMAL_TEXTURE\"] = this.supportsNormalTexture ? 1 : 0;\n      this.saoMaterial.defines[\"PERSPECTIVE_CAMERA\"] = this.camera.isPerspectiveCamera ? 1 : 0;\n      this.saoMaterial.uniforms[\"tDepth\"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n      this.saoMaterial.uniforms[\"tNormal\"].value = this.normalRenderTarget.texture;\n      this.saoMaterial.uniforms[\"size\"].value.set(this.resolution.x, this.resolution.y);\n      this.saoMaterial.uniforms[\"cameraInverseProjectionMatrix\"].value.copy(this.camera.projectionMatrixInverse);\n      this.saoMaterial.uniforms[\"cameraProjectionMatrix\"].value = this.camera.projectionMatrix;\n      this.saoMaterial.blending = NoBlending;\n      this.vBlurMaterial = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\n        defines: Object.assign({}, DepthLimitedBlurShader.defines),\n        vertexShader: DepthLimitedBlurShader.vertexShader,\n        fragmentShader: DepthLimitedBlurShader.fragmentShader\n      });\n      this.vBlurMaterial.defines[\"DEPTH_PACKING\"] = this.supportsDepthTextureExtension ? 0 : 1;\n      this.vBlurMaterial.defines[\"PERSPECTIVE_CAMERA\"] = this.camera.isPerspectiveCamera ? 1 : 0;\n      this.vBlurMaterial.uniforms[\"tDiffuse\"].value = this.saoRenderTarget.texture;\n      this.vBlurMaterial.uniforms[\"tDepth\"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n      this.vBlurMaterial.uniforms[\"size\"].value.set(this.resolution.x, this.resolution.y);\n      this.vBlurMaterial.blending = NoBlending;\n      this.hBlurMaterial = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\n        defines: Object.assign({}, DepthLimitedBlurShader.defines),\n        vertexShader: DepthLimitedBlurShader.vertexShader,\n        fragmentShader: DepthLimitedBlurShader.fragmentShader\n      });\n      this.hBlurMaterial.defines[\"DEPTH_PACKING\"] = this.supportsDepthTextureExtension ? 0 : 1;\n      this.hBlurMaterial.defines[\"PERSPECTIVE_CAMERA\"] = this.camera.isPerspectiveCamera ? 1 : 0;\n      this.hBlurMaterial.uniforms[\"tDiffuse\"].value = this.blurIntermediateRenderTarget.texture;\n      this.hBlurMaterial.uniforms[\"tDepth\"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n      this.hBlurMaterial.uniforms[\"size\"].value.set(this.resolution.x, this.resolution.y);\n      this.hBlurMaterial.blending = NoBlending;\n      this.materialCopy = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(CopyShader.uniforms),\n        vertexShader: CopyShader.vertexShader,\n        fragmentShader: CopyShader.fragmentShader,\n        blending: NoBlending\n      });\n      this.materialCopy.transparent = true;\n      this.materialCopy.depthTest = false;\n      this.materialCopy.depthWrite = false;\n      this.materialCopy.blending = CustomBlending;\n      this.materialCopy.blendSrc = DstColorFactor;\n      this.materialCopy.blendDst = ZeroFactor;\n      this.materialCopy.blendEquation = AddEquation;\n      this.materialCopy.blendSrcAlpha = DstAlphaFactor;\n      this.materialCopy.blendDstAlpha = ZeroFactor;\n      this.materialCopy.blendEquationAlpha = AddEquation;\n      this.depthCopy = new ShaderMaterial({\n        uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),\n        vertexShader: UnpackDepthRGBAShader.vertexShader,\n        fragmentShader: UnpackDepthRGBAShader.fragmentShader,\n        blending: NoBlending\n      });\n      this.fsQuad = new FullScreenQuad(null);\n    }\n    render(renderer, writeBuffer, readBuffer) {\n      if (this.renderToScreen) {\n        this.materialCopy.blending = NoBlending;\n        this.materialCopy.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n        this.materialCopy.needsUpdate = true;\n        this.renderPass(renderer, this.materialCopy, null);\n      }\n      if (this.params.output === 1) {\n        return;\n      }\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.setRenderTarget(this.depthRenderTarget);\n      renderer.clear();\n      this.saoMaterial.uniforms[\"bias\"].value = this.params.saoBias;\n      this.saoMaterial.uniforms[\"intensity\"].value = this.params.saoIntensity;\n      this.saoMaterial.uniforms[\"scale\"].value = this.params.saoScale;\n      this.saoMaterial.uniforms[\"kernelRadius\"].value = this.params.saoKernelRadius;\n      this.saoMaterial.uniforms[\"minResolution\"].value = this.params.saoMinResolution;\n      this.saoMaterial.uniforms[\"cameraNear\"].value = this.camera.near;\n      this.saoMaterial.uniforms[\"cameraFar\"].value = this.camera.far;\n      const depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);\n      this.vBlurMaterial.uniforms[\"depthCutoff\"].value = depthCutoff;\n      this.hBlurMaterial.uniforms[\"depthCutoff\"].value = depthCutoff;\n      this.vBlurMaterial.uniforms[\"cameraNear\"].value = this.camera.near;\n      this.vBlurMaterial.uniforms[\"cameraFar\"].value = this.camera.far;\n      this.hBlurMaterial.uniforms[\"cameraNear\"].value = this.camera.near;\n      this.hBlurMaterial.uniforms[\"cameraFar\"].value = this.camera.far;\n      this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);\n      if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {\n        BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));\n        BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));\n        this.prevStdDev = this.params.saoBlurStdDev;\n        this.prevNumSamples = this.params.saoBlurRadius;\n      }\n      renderer.setClearColor(0);\n      renderer.setRenderTarget(this.beautyRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      if (!this.supportsDepthTextureExtension) {\n        this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0, 1);\n      }\n      if (this.supportsNormalTexture) {\n        this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);\n      }\n      this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 16777215, 1);\n      if (this.params.saoBlur) {\n        this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1);\n        this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1);\n      }\n      let outputMaterial = this.materialCopy;\n      if (this.params.output === 3) {\n        if (this.supportsDepthTextureExtension) {\n          this.materialCopy.uniforms[\"tDiffuse\"].value = this.beautyRenderTarget.depthTexture;\n          this.materialCopy.needsUpdate = true;\n        } else {\n          this.depthCopy.uniforms[\"tDiffuse\"].value = this.depthRenderTarget.texture;\n          this.depthCopy.needsUpdate = true;\n          outputMaterial = this.depthCopy;\n        }\n      } else if (this.params.output === 4) {\n        this.materialCopy.uniforms[\"tDiffuse\"].value = this.normalRenderTarget.texture;\n        this.materialCopy.needsUpdate = true;\n      } else {\n        this.materialCopy.uniforms[\"tDiffuse\"].value = this.saoRenderTarget.texture;\n        this.materialCopy.needsUpdate = true;\n      }\n      if (this.params.output === 0) {\n        outputMaterial.blending = CustomBlending;\n      } else {\n        outputMaterial.blending = NoBlending;\n      }\n      this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n      renderer.getClearColor(this.originalClearColor);\n      const originalClearAlpha = renderer.getClearAlpha();\n      const originalAutoClear = renderer.autoClear;\n      renderer.setRenderTarget(renderTarget);\n      renderer.autoClear = false;\n      if (clearColor !== void 0 && clearColor !== null) {\n        renderer.setClearColor(clearColor);\n        renderer.setClearAlpha(clearAlpha || 0);\n        renderer.clear();\n      }\n      this.fsQuad.material = passMaterial;\n      this.fsQuad.render(renderer);\n      renderer.autoClear = originalAutoClear;\n      renderer.setClearColor(this.originalClearColor);\n      renderer.setClearAlpha(originalClearAlpha);\n    }\n    renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n      renderer.getClearColor(this.originalClearColor);\n      const originalClearAlpha = renderer.getClearAlpha();\n      const originalAutoClear = renderer.autoClear;\n      renderer.setRenderTarget(renderTarget);\n      renderer.autoClear = false;\n      clearColor = overrideMaterial.clearColor || clearColor;\n      clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n      if (clearColor !== void 0 && clearColor !== null) {\n        renderer.setClearColor(clearColor);\n        renderer.setClearAlpha(clearAlpha || 0);\n        renderer.clear();\n      }\n      this.scene.overrideMaterial = overrideMaterial;\n      renderer.render(this.scene, this.camera);\n      this.scene.overrideMaterial = null;\n      renderer.autoClear = originalAutoClear;\n      renderer.setClearColor(this.originalClearColor);\n      renderer.setClearAlpha(originalClearAlpha);\n    }\n    setSize(width, height) {\n      this.beautyRenderTarget.setSize(width, height);\n      this.saoRenderTarget.setSize(width, height);\n      this.blurIntermediateRenderTarget.setSize(width, height);\n      this.normalRenderTarget.setSize(width, height);\n      this.depthRenderTarget.setSize(width, height);\n      this.saoMaterial.uniforms[\"size\"].value.set(width, height);\n      this.saoMaterial.uniforms[\"cameraInverseProjectionMatrix\"].value.copy(this.camera.projectionMatrixInverse);\n      this.saoMaterial.uniforms[\"cameraProjectionMatrix\"].value = this.camera.projectionMatrix;\n      this.saoMaterial.needsUpdate = true;\n      this.vBlurMaterial.uniforms[\"size\"].value.set(width, height);\n      this.vBlurMaterial.needsUpdate = true;\n      this.hBlurMaterial.uniforms[\"size\"].value.set(width, height);\n      this.hBlurMaterial.needsUpdate = true;\n    }\n    dispose() {\n      this.saoRenderTarget.dispose();\n      this.blurIntermediateRenderTarget.dispose();\n      this.beautyRenderTarget.dispose();\n      this.normalRenderTarget.dispose();\n      this.depthRenderTarget.dispose();\n      this.depthMaterial.dispose();\n      this.normalMaterial.dispose();\n      this.saoMaterial.dispose();\n      this.vBlurMaterial.dispose();\n      this.hBlurMaterial.dispose();\n      this.materialCopy.dispose();\n      this.depthCopy.dispose();\n      this.fsQuad.dispose();\n    }\n  }\n  __publicField(SAOPass2, \"OUTPUT\", {\n    Beauty: 1,\n    Default: 0,\n    SAO: 2,\n    Depth: 3,\n    Normal: 4\n  });\n  return SAOPass2;\n})();\nexport { SAOPass };\n//# sourceMappingURL=SAOPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}