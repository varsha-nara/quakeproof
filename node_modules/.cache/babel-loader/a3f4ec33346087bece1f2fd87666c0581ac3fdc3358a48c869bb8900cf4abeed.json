{"ast":null,"code":"import { Vector2 } from \"three\";\nconst ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: \"25.0\",\n    KERNEL_SIZE_INT: \"25\"\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: /* @__PURE__ */new Vector2(1953125e-9, 0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: (/* glsl */\n  `\n    uniform vec2 uImageIncrement;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `),\n  fragmentShader: (/* glsl */\n  `\n    uniform float cKernel[ KERNEL_SIZE_INT ];\n\n    uniform sampler2D tDiffuse;\n    uniform vec2 uImageIncrement;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec2 imageCoord = vUv;\n    \tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n    \tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n    \t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n    \t\timageCoord += uImageIncrement;\n\n    \t}\n\n    \tgl_FragColor = sum;\n\n    }\n  `),\n  buildKernel: function (sigma) {\n    function gauss(x, sigma2) {\n      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));\n    }\n    const kMaxKernelSize = 25;\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0;\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    }\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\n    return values;\n  }\n};\nexport { ConvolutionShader };\n//# sourceMappingURL=ConvolutionShader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}