{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter } from \"three\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nconst BasisTextureLoader = /* @__PURE__ */(() => {\n  const _BasisTextureLoader = class extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.transcoderPath = \"\";\n      this.transcoderBinary = null;\n      this.transcoderPending = null;\n      this.workerLimit = 4;\n      this.workerPool = [];\n      this.workerNextTaskID = 1;\n      this.workerSourceURL = \"\";\n      this.workerConfig = null;\n    }\n    setTranscoderPath(path) {\n      this.transcoderPath = path;\n      return this;\n    }\n    setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n    detectSupport(renderer) {\n      this.workerConfig = {\n        astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n        etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n        etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n        dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n        bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n        pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n      };\n      return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n      const loader = new FileLoader(this.manager);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setWithCredentials(this.withCredentials);\n      const texture = new CompressedTexture();\n      loader.load(url, buffer => {\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer);\n          return cachedTask.promise.then(onLoad).catch(onError);\n        }\n        this._createTexture([buffer]).then(function (_texture) {\n          texture.copy(_texture);\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }).catch(onError);\n      }, onProgress, onError);\n      return texture;\n    }\n    /** Low-level transcoding API, exposed for use by KTX2Loader. */\n    parseInternalAsync(options) {\n      const {\n        levels\n      } = options;\n      const buffers = /* @__PURE__ */new Set();\n      for (let i = 0; i < levels.length; i++) {\n        buffers.add(levels[i].data.buffer);\n      }\n      return this._createTexture(Array.from(buffers), {\n        ...options,\n        lowLevel: true\n      });\n    }\n    /**\n     * @param {ArrayBuffer[]} buffers\n     * @param {object?} config\n     * @return {Promise<CompressedTexture>}\n     */\n    _createTexture(buffers, config = {}) {\n      let worker;\n      let taskID;\n      const taskConfig = config;\n      let taskCost = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        taskCost += buffers[i].byteLength;\n      }\n      const texturePending = this._allocateWorker(taskCost).then(_worker => {\n        worker = _worker;\n        taskID = this.workerNextTaskID++;\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = {\n            resolve,\n            reject\n          };\n          worker.postMessage({\n            type: \"transcode\",\n            id: taskID,\n            buffers,\n            taskConfig\n          }, buffers);\n        });\n      }).then(message => {\n        const {\n          mipmaps,\n          width,\n          height,\n          format\n        } = message;\n        const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n        texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.needsUpdate = true;\n        return texture;\n      });\n      texturePending.catch(() => true).then(() => {\n        if (worker && taskID) {\n          worker._taskLoad -= taskCost;\n          delete worker._callbacks[taskID];\n        }\n      });\n      _taskCache.set(buffers[0], {\n        promise: texturePending\n      });\n      return texturePending;\n    }\n    _initTranscoder() {\n      if (!this.transcoderPending) {\n        const jsLoader = new FileLoader(this.manager);\n        jsLoader.setPath(this.transcoderPath);\n        jsLoader.setWithCredentials(this.withCredentials);\n        const jsContent = new Promise((resolve, reject) => {\n          jsLoader.load(\"basis_transcoder.js\", resolve, void 0, reject);\n        });\n        const binaryLoader = new FileLoader(this.manager);\n        binaryLoader.setPath(this.transcoderPath);\n        binaryLoader.setResponseType(\"arraybuffer\");\n        binaryLoader.setWithCredentials(this.withCredentials);\n        const binaryContent = new Promise((resolve, reject) => {\n          binaryLoader.load(\"basis_transcoder.wasm\", resolve, void 0, reject);\n        });\n        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n          const fn = _BasisTextureLoader.BasisWorker.toString();\n          const body = [\"/* constants */\", \"let _EngineFormat = \" + JSON.stringify(_BasisTextureLoader.EngineFormat), \"let _TranscoderFormat = \" + JSON.stringify(_BasisTextureLoader.TranscoderFormat), \"let _BasisFormat = \" + JSON.stringify(_BasisTextureLoader.BasisFormat), \"/* basis_transcoder.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n          this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n          this.transcoderBinary = binaryContent2;\n        });\n      }\n      return this.transcoderPending;\n    }\n    _allocateWorker(taskCost) {\n      return this._initTranscoder().then(() => {\n        if (this.workerPool.length < this.workerLimit) {\n          const worker2 = new Worker(this.workerSourceURL);\n          worker2._callbacks = {};\n          worker2._taskLoad = 0;\n          worker2.postMessage({\n            type: \"init\",\n            config: this.workerConfig,\n            transcoderBinary: this.transcoderBinary\n          });\n          worker2.onmessage = function (e) {\n            const message = e.data;\n            switch (message.type) {\n              case \"transcode\":\n                worker2._callbacks[message.id].resolve(message);\n                break;\n              case \"error\":\n                worker2._callbacks[message.id].reject(message);\n                break;\n              default:\n                console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n          this.workerPool.push(worker2);\n        } else {\n          this.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n        const worker = this.workerPool[this.workerPool.length - 1];\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n    dispose() {\n      for (let i = 0; i < this.workerPool.length; i++) {\n        this.workerPool[i].terminate();\n      }\n      this.workerPool.length = 0;\n      return this;\n    }\n  };\n  let BasisTextureLoader2 = _BasisTextureLoader;\n  /* CONSTANTS */\n  __publicField(BasisTextureLoader2, \"BasisFormat\", {\n    ETC1S: 0,\n    UASTC_4x4: 1\n  });\n  __publicField(BasisTextureLoader2, \"TranscoderFormat\", {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16\n  });\n  __publicField(BasisTextureLoader2, \"EngineFormat\", {\n    RGBAFormat,\n    RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format,\n    RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format\n  });\n  /* WEB WORKER */\n  __publicField(BasisTextureLoader2, \"BasisWorker\", function () {\n    let config;\n    let transcoderPending;\n    let BasisModule;\n    const EngineFormat = _EngineFormat;\n    const TranscoderFormat = _TranscoderFormat;\n    const BasisFormat = _BasisFormat;\n    onmessage = function (e) {\n      const message = e.data;\n      switch (message.type) {\n        case \"init\":\n          config = message.config;\n          init(message.transcoderBinary);\n          break;\n        case \"transcode\":\n          transcoderPending.then(() => {\n            try {\n              const {\n                width,\n                height,\n                hasAlpha,\n                mipmaps,\n                format\n              } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);\n              const buffers = [];\n              for (let i = 0; i < mipmaps.length; ++i) {\n                buffers.push(mipmaps[i].data.buffer);\n              }\n              self.postMessage({\n                type: \"transcode\",\n                id: message.id,\n                width,\n                height,\n                hasAlpha,\n                mipmaps,\n                format\n              }, buffers);\n            } catch (error) {\n              console.error(error);\n              self.postMessage({\n                type: \"error\",\n                id: message.id,\n                error: error.message\n              });\n            }\n          });\n          break;\n      }\n    };\n    function init(wasmBinary) {\n      transcoderPending = new Promise(resolve => {\n        BasisModule = {\n          wasmBinary,\n          onRuntimeInitialized: resolve\n        };\n        BASIS(BasisModule);\n      }).then(() => {\n        BasisModule.initializeBasis();\n      });\n    }\n    function transcodeLowLevel(taskConfig) {\n      const {\n        basisFormat,\n        width,\n        height,\n        hasAlpha\n      } = taskConfig;\n      const {\n        transcoderFormat,\n        engineFormat\n      } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n      assert(BasisModule.isFormatSupported(transcoderFormat), \"THREE.BasisTextureLoader: Unsupported format.\");\n      const mipmaps = [];\n      if (basisFormat === BasisFormat.ETC1S) {\n        const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n        const {\n          endpointCount,\n          endpointsData,\n          selectorCount,\n          selectorsData,\n          tablesData\n        } = taskConfig.globalData;\n        try {\n          let ok;\n          ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n          assert(ok, \"THREE.BasisTextureLoader: decodePalettes() failed.\");\n          ok = transcoder.decodeTables(tablesData);\n          assert(ok, \"THREE.BasisTextureLoader: decodeTables() failed.\");\n          for (let i = 0; i < taskConfig.levels.length; i++) {\n            const level = taskConfig.levels[i];\n            const imageDesc = taskConfig.globalData.imageDescs[i];\n            const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n            const dst = new Uint8Array(dstByteLength);\n            ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n            assert(ok, \"THREE.BasisTextureLoader: transcodeImage() failed for level \" + level.index + \".\");\n            mipmaps.push({\n              data: dst,\n              width: level.width,\n              height: level.height\n            });\n          }\n        } finally {\n          transcoder.delete();\n        }\n      } else {\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i];\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          const dst = new Uint8Array(dstByteLength);\n          const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n          assert(ok, \"THREE.BasisTextureLoader: transcodeUASTCImage() failed for level \" + level.index + \".\");\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      }\n      return {\n        width,\n        height,\n        hasAlpha,\n        mipmaps,\n        format: engineFormat\n      };\n    }\n    function transcode(buffer) {\n      const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n      const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n      const width = basisFile.getImageWidth(0, 0);\n      const height = basisFile.getImageHeight(0, 0);\n      const levels = basisFile.getNumLevels(0);\n      const hasAlpha = basisFile.getHasAlpha();\n      function cleanup() {\n        basisFile.close();\n        basisFile.delete();\n      }\n      const {\n        transcoderFormat,\n        engineFormat\n      } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n      if (!width || !height || !levels) {\n        cleanup();\n        throw new Error(\"THREE.BasisTextureLoader:\tInvalid texture\");\n      }\n      if (!basisFile.startTranscoding()) {\n        cleanup();\n        throw new Error(\"THREE.BasisTextureLoader: .startTranscoding failed\");\n      }\n      const mipmaps = [];\n      for (let mip = 0; mip < levels; mip++) {\n        const mipWidth = basisFile.getImageWidth(0, mip);\n        const mipHeight = basisFile.getImageHeight(0, mip);\n        const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n        const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n        if (!status) {\n          cleanup();\n          throw new Error(\"THREE.BasisTextureLoader: .transcodeImage failed.\");\n        }\n        mipmaps.push({\n          data: dst,\n          width: mipWidth,\n          height: mipHeight\n        });\n      }\n      cleanup();\n      return {\n        width,\n        height,\n        hasAlpha,\n        mipmaps,\n        format: engineFormat\n      };\n    }\n    const FORMAT_OPTIONS = [{\n      if: \"astcSupported\",\n      basisFormat: [BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n      priorityETC1S: Infinity,\n      priorityUASTC: 1,\n      needsPowerOfTwo: false\n    }, {\n      if: \"bptcSupported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n      priorityETC1S: 3,\n      priorityUASTC: 2,\n      needsPowerOfTwo: false\n    }, {\n      if: \"dxtSupported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n      engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n      priorityETC1S: 4,\n      priorityUASTC: 5,\n      needsPowerOfTwo: false\n    }, {\n      if: \"etc2Supported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n      priorityETC1S: 1,\n      priorityUASTC: 3,\n      needsPowerOfTwo: false\n    }, {\n      if: \"etc1Supported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n      engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n      priorityETC1S: 2,\n      priorityUASTC: 4,\n      needsPowerOfTwo: false\n    }, {\n      if: \"pvrtcSupported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n      priorityETC1S: 5,\n      priorityUASTC: 6,\n      needsPowerOfTwo: true\n    }];\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S;\n    });\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC;\n    });\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat;\n      let engineFormat;\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i];\n        if (!config[opt.if]) continue;\n        if (!opt.basisFormat.includes(basisFormat)) continue;\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n        return {\n          transcoderFormat,\n          engineFormat\n        };\n      }\n      console.warn(\"THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.\");\n      transcoderFormat = TranscoderFormat.RGBA32;\n      engineFormat = EngineFormat.RGBAFormat;\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n    function assert(ok, message) {\n      if (!ok) throw new Error(message);\n    }\n    function getWidthInBlocks(transcoderFormat, width) {\n      return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n    }\n    function getHeightInBlocks(transcoderFormat, height) {\n      return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n    }\n    function getTranscodedImageByteLength(transcoderFormat, width, height) {\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n      if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n        return width * height * blockByteLength;\n      }\n      if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n        const paddedWidth = width + 3 & ~3;\n        const paddedHeight = height + 3 & ~3;\n        return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n      }\n      return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n    }\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true;\n      return (value & value - 1) === 0 && value !== 0;\n    }\n  });\n  return BasisTextureLoader2;\n})();\nexport { BasisTextureLoader };\n//# sourceMappingURL=BasisTextureLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}