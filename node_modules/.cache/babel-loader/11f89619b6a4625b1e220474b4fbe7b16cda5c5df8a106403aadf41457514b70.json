{"ast":null,"code":"/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType } from 'three';\n\n/**\n * Shared decode implementation factory\n * Creates a decode function that prepares a QuadRenderer with the given parameters\n */\nfunction createDecodeFunction(config) {\n  return params => {\n    const {\n      sdr,\n      gainMap,\n      renderer\n    } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n      console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n      sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n      console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n      gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = config.createMaterial({\n      ...params,\n      sdr,\n      gainMap\n    });\n    const quadRenderer = config.createQuadRenderer({\n      width: sdr.image.width,\n      height: sdr.image.height,\n      type: HalfFloatType,\n      colorSpace: LinearSRGBColorSpace,\n      material,\n      renderer,\n      renderTargetOptions: params.renderTargetOptions\n    });\n    return quadRenderer;\n  };\n}\nclass GainMapNotFoundError extends Error {}\nclass XMPMetadataNotFoundError extends Error {}\nconst getXMLValue = (xml, tag, defaultValue) => {\n  // Check for attribute format first: tag=\"value\"\n  const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n  if (attributeMatch) return attributeMatch[1];\n  // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n  const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n  if (tagMatch) {\n    // Check if it contains rdf:li elements\n    const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n    if (liValues && liValues.length === 3) {\n      return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n    }\n    return tagMatch[1].trim();\n  }\n  if (defaultValue !== undefined) return defaultValue;\n  throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = input => {\n  let str;\n  // support node test environment\n  if (typeof TextDecoder !== 'undefined') str = new TextDecoder().decode(input);else str = input.toString();\n  let start = str.indexOf('<x:xmpmeta');\n  while (start !== -1) {\n    const end = str.indexOf('x:xmpmeta>', start);\n    const xmpBlock = str.slice(start, end + 10);\n    try {\n      const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n      const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n      const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n      const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n      const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n      // These are always attributes, so we can use a simpler regex\n      const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n      const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n      const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n      if (!hdrCapacityMaxMatch) throw new Error('Incomplete gainmap metadata');\n      const hdrCapacityMax = hdrCapacityMaxMatch[1];\n      return {\n        gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n        gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n        gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n        offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n        offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n        hdrCapacityMin: parseFloat(hdrCapacityMin),\n        hdrCapacityMax: parseFloat(hdrCapacityMax)\n      };\n    } catch (e) {\n      // Continue searching for another xmpmeta block if this one fails\n    }\n    start = str.indexOf('<x:xmpmeta', end);\n  }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n  options;\n  constructor(options) {\n    this.options = {\n      debug: options && options.debug !== undefined ? options.debug : false,\n      extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n      extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n    };\n  }\n  extract(imageArrayBuffer) {\n    return new Promise((resolve, reject) => {\n      const debug = this.options.debug;\n      const dataView = new DataView(imageArrayBuffer.buffer);\n      // If you're executing this line on a big endian machine, it'll be reversed.\n      // bigEnd further down though, refers to the endianness of the image itself.\n      if (dataView.getUint16(0) !== 0xffd8) {\n        reject(new Error('Not a valid jpeg'));\n        return;\n      }\n      const length = dataView.byteLength;\n      let offset = 2;\n      let loops = 0;\n      let marker; // APP# marker\n      while (offset < length) {\n        if (++loops > 250) {\n          reject(new Error(`Found no marker after ${loops} loops üòµ`));\n          return;\n        }\n        if (dataView.getUint8(offset) !== 0xff) {\n          reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n          return;\n        }\n        marker = dataView.getUint8(offset + 1);\n        if (debug) console.log(`Marker: ${marker.toString(16)}`);\n        if (marker === 0xe2) {\n          if (debug) console.log('Found APP2 marker (0xffe2)');\n          // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n          // Great way to visualize image information in html is using Exiftool. E.g.:\n          // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n          const formatPt = offset + 4;\n          /*\n           *  Structure of the MP Format Identifier\n           *\n           *  Offset Addr.  | Code (Hex)  | Description\n           *  +00             ff            Marker Prefix      <-- offset\n           *  +01             e2            APP2\n           *  +02             #n            APP2 Field Length\n           *  +03             #n            APP2 Field Length\n           *  +04             4d            'M'                <-- formatPt\n           *  +05             50            'P'\n           *  +06             46            'F'\n           *  +07             00            NULL\n           *                                                   <-- tiffOffset\n           */\n          if (dataView.getUint32(formatPt) === 0x4d504600) {\n            // Found MPF tag, so we start dig out sub images\n            const tiffOffset = formatPt + 4;\n            let bigEnd; // Endianness from TIFF header\n            // Test for TIFF validity and endianness\n            // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n            if (dataView.getUint16(tiffOffset) === 0x4949) {\n              bigEnd = false;\n            } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n              bigEnd = true;\n            } else {\n              reject(new Error('No valid endianness marker found in TIFF header'));\n              return;\n            }\n            if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n              reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n              return;\n            }\n            // 32 bit number stating the offset from the start of the 8 Byte MP Header\n            // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n            const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n            if (firstIFDOffset < 0x00000008) {\n              reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n              return;\n            }\n            // Move ahead to MP Index IFD\n            // Assume we're at the first IFD, so firstIFDOffset points to\n            // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n            // we fail silently here due to this assumption)\n            // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n            const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n            const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n            // Extract info from MPEntries (starting after Count)\n            const entriesStart = dirStart + 2;\n            let numberOfImages = 0;\n            for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n              // Each entry is 12 Bytes long\n              // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n              if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                // stored in Last 4 bytes of its 12 Byte entry.\n                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n              }\n            }\n            const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n            const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n            const images = [];\n            for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n              const image = {\n                MPType: dataView.getUint32(i, !bigEnd),\n                size: dataView.getUint32(i + 4, !bigEnd),\n                // This offset is specified relative to the address of the MP Endian\n                // field in the MP Header, unless the image is a First Individual Image,\n                // in which case the value of the offset shall be NULL (0x00000000).\n                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                start: -1,\n                end: -1,\n                isFII: false\n              };\n              if (!image.dataOffset) {\n                // dataOffset is 0x00000000 for First Individual Image\n                image.start = 0;\n                image.isFII = true;\n              } else {\n                image.start = tiffOffset + image.dataOffset;\n                image.isFII = false;\n              }\n              image.end = image.start + image.size;\n              images.push(image);\n            }\n            if (this.options.extractNonFII && images.length) {\n              const bufferBlob = new Blob([dataView]);\n              const imgs = [];\n              for (const image of images) {\n                if (image.isFII && !this.options.extractFII) {\n                  continue; // Skip FII\n                }\n                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                // we don't need this\n                // const imageUrl = URL.createObjectURL(imageBlob)\n                // image.img = document.createElement('img')\n                // image.img.src = imageUrl\n                imgs.push(imageBlob);\n              }\n              resolve(imgs);\n            }\n          }\n        }\n        offset += 2 + dataView.getUint16(offset + 2);\n      }\n    });\n  }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async jpegFile => {\n  const metadata = extractXMP(jpegFile);\n  if (!metadata) throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n  const mpfExtractor = new MPFExtractor({\n    extractFII: true,\n    extractNonFII: true\n  });\n  const images = await mpfExtractor.extract(jpegFile);\n  if (images.length !== 2) throw new GainMapNotFoundError('Gain map recovery image not found');\n  return {\n    sdr: new Uint8Array(await images[0].arrayBuffer()),\n    gainMap: new Uint8Array(await images[1].arrayBuffer()),\n    metadata\n  };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = blob => {\n  return new Promise((resolve, reject) => {\n    const img = document.createElement('img');\n    img.onload = () => {\n      resolve(img);\n    };\n    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n    img.onerror = e => {\n      reject(e);\n    };\n    img.src = URL.createObjectURL(blob);\n  });\n};\n\n/**\n * Shared base class for loaders that extracts common logic\n */\nclass LoaderBaseShared extends Loader {\n  _renderer;\n  _renderTargetOptions;\n  _internalLoadingManager;\n  _config;\n  constructor(config, manager) {\n    super(manager);\n    this._config = config;\n    if (config.renderer) this._renderer = config.renderer;\n    this._internalLoadingManager = new LoadingManager();\n  }\n  setRenderer(renderer) {\n    this._renderer = renderer;\n    return this;\n  }\n  setRenderTargetOptions(options) {\n    this._renderTargetOptions = options;\n    return this;\n  }\n  prepareQuadRenderer() {\n    if (!this._renderer) {\n      console.warn('WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n    }\n    const material = this._config.createMaterial({\n      gainMapMax: [1, 1, 1],\n      gainMapMin: [0, 0, 0],\n      gamma: [1, 1, 1],\n      offsetHdr: [1, 1, 1],\n      offsetSdr: [1, 1, 1],\n      hdrCapacityMax: 1,\n      hdrCapacityMin: 0,\n      maxDisplayBoost: 1,\n      gainMap: new Texture(),\n      sdr: new Texture()\n    });\n    return this._config.createQuadRenderer({\n      width: 16,\n      height: 16,\n      type: HalfFloatType,\n      colorSpace: LinearSRGBColorSpace,\n      material,\n      renderer: this._renderer,\n      renderTargetOptions: this._renderTargetOptions\n    });\n  }\n  async processImages(sdrBuffer, gainMapBuffer, imageOrientation) {\n    const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], {\n      type: 'image/jpeg'\n    }) : undefined;\n    const sdrBlob = new Blob([sdrBuffer], {\n      type: 'image/jpeg'\n    });\n    let sdrImage;\n    let gainMapImage;\n    let needsFlip = false;\n    if (typeof createImageBitmap === 'undefined') {\n      const res = await Promise.all([gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined), getHTMLImageFromBlob(sdrBlob)]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n      needsFlip = imageOrientation === 'flipY';\n    } else {\n      const res = await Promise.all([gainMapBlob ? createImageBitmap(gainMapBlob, {\n        imageOrientation: imageOrientation || 'flipY'\n      }) : Promise.resolve(undefined), createImageBitmap(sdrBlob, {\n        imageOrientation: imageOrientation || 'flipY'\n      })]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n    }\n    return {\n      sdrImage,\n      gainMapImage,\n      needsFlip\n    };\n  }\n  createTextures(sdrImage, gainMapImage, needsFlip) {\n    const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n    gainMap.flipY = needsFlip;\n    gainMap.needsUpdate = true;\n    const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n    sdr.flipY = needsFlip;\n    sdr.needsUpdate = true;\n    return {\n      gainMap,\n      sdr\n    };\n  }\n  updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {\n    quadRenderer.width = sdrImage.width;\n    quadRenderer.height = sdrImage.height;\n    quadRenderer.material.gainMap = gainMap;\n    quadRenderer.material.sdr = sdr;\n    quadRenderer.material.gainMapMin = metadata.gainMapMin;\n    quadRenderer.material.gainMapMax = metadata.gainMapMax;\n    quadRenderer.material.offsetHdr = metadata.offsetHdr;\n    quadRenderer.material.offsetSdr = metadata.offsetSdr;\n    quadRenderer.material.gamma = metadata.gamma;\n    quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n    quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n    quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n    quadRenderer.material.needsUpdate = true;\n  }\n}\nexport { GainMapNotFoundError as G, LoaderBaseShared as L, MPFExtractor as M, XMPMetadataNotFoundError as X, extractXMP as a, createDecodeFunction as c, extractGainmapFromJPEG as e };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}