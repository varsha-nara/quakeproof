{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nconst LightningStrike = /* @__PURE__ */(() => {\n  const _LightningStrike = class extends BufferGeometry {\n    constructor(rayParameters = {}) {\n      super();\n      this.isLightningStrike = true;\n      this.type = \"LightningStrike\";\n      this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n      this.createMesh();\n    }\n    static createRandomGenerator() {\n      const numSeeds = 2053;\n      const seeds = [];\n      for (let i = 0; i < numSeeds; i++) {\n        seeds.push(Math.random());\n      }\n      const generator = {\n        currentSeed: 0,\n        random: function () {\n          const value = seeds[generator.currentSeed];\n          generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n          return value;\n        },\n        getSeed: function () {\n          return generator.currentSeed / numSeeds;\n        },\n        setSeed: function (seed) {\n          generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n        }\n      };\n      return generator;\n    }\n    static copyParameters(dest = {}, source = {}) {\n      const vecCopy = function (v) {\n        if (source === dest) {\n          return v;\n        } else {\n          return v.clone();\n        }\n      };\n      dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n      dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2,\n      // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n      dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n      dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n      dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n      dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n      dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n      dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n      dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n      dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n      return dest;\n    }\n    update(time) {\n      if (this.isStatic) return;\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n        this.updateMesh(time);\n        if (time < this.subrays[0].endPropagationTime) {\n          this.state = _LightningStrike.RAY_PROPAGATING;\n        } else if (time > this.subrays[0].beginVanishingTime) {\n          this.state = _LightningStrike.RAY_VANISHING;\n        } else {\n          this.state = _LightningStrike.RAY_STEADY;\n        }\n        this.visible = true;\n      } else {\n        this.visible = false;\n        if (time < this.rayParameters.birthTime) {\n          this.state = _LightningStrike.RAY_UNBORN;\n        } else {\n          this.state = _LightningStrike.RAY_EXTINGUISHED;\n        }\n      }\n    }\n    init(rayParameters) {\n      this.rayParameters = rayParameters;\n      this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n      rayParameters.maxIterations = this.maxIterations;\n      this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n      rayParameters.isStatic = this.isStatic;\n      this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n      rayParameters.ramification = this.ramification;\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n      this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n      rayParameters.recursionProbability = this.recursionProbability;\n      this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n      rayParameters.generateUVs = this.generateUVs;\n      if (rayParameters.randomGenerator !== void 0) {\n        this.randomGenerator = rayParameters.randomGenerator;\n        this.seedGenerator = rayParameters.randomGenerator;\n        if (rayParameters.noiseSeed !== void 0) {\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\n        }\n      } else {\n        this.randomGenerator = _LightningStrike.createRandomGenerator();\n        this.seedGenerator = Math;\n      }\n      if (rayParameters.onDecideSubrayCreation !== void 0) {\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n      } else {\n        this.createDefaultSubrayCreationCallbacks();\n        if (rayParameters.onSubrayCreation !== void 0) {\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\n        }\n      }\n      this.state = _LightningStrike.RAY_INITIALIZED;\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n      rayParameters.maxSubrays = this.maxSubrays;\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\n      this.subrays = [];\n      for (let i = 0; i < this.maxSubrays; i++) {\n        this.subrays.push(this.createSubray());\n      }\n      this.raySegments = [];\n      for (let i = 0; i < this.maxRaySegments; i++) {\n        this.raySegments.push(this.createSegment());\n      }\n      this.time = 0;\n      this.timeFraction = 0;\n      this.currentSegmentCallback = null;\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n      this.numSubrays = 0;\n      this.currentSubray = null;\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = false;\n      this.subrayProbability = 0;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.vertices = null;\n      this.uvs = null;\n      this.indices = null;\n      this.positionAttribute = null;\n      this.uvsAttribute = null;\n      this.simplexX = new SimplexNoise(this.seedGenerator);\n      this.simplexY = new SimplexNoise(this.seedGenerator);\n      this.simplexZ = new SimplexNoise(this.seedGenerator);\n      this.forwards = new Vector3();\n      this.forwardsFill = new Vector3();\n      this.side = new Vector3();\n      this.down = new Vector3();\n      this.middlePos = new Vector3();\n      this.middleLinPos = new Vector3();\n      this.newPos = new Vector3();\n      this.vPos = new Vector3();\n      this.cross1 = new Vector3();\n    }\n    createMesh() {\n      const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n      const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n      const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n      this.vertices = new Float32Array(maxVerts * 3);\n      this.indices = new Uint32Array(maxIndices);\n      if (this.generateUVs) {\n        this.uvs = new Float32Array(maxVerts * 2);\n      }\n      this.fillMesh(0);\n      this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n      this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n      this.setAttribute(\"position\", this.positionAttribute);\n      if (this.generateUVs) {\n        this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n        this.setAttribute(\"uv\", this.uvsAttribute);\n      }\n      if (!this.isStatic) {\n        this.index.usage = DynamicDrawUsage;\n        this.positionAttribute.usage = DynamicDrawUsage;\n        if (this.generateUVs) {\n          this.uvsAttribute.usage = DynamicDrawUsage;\n        }\n      }\n      this.vertices = this.positionAttribute.array;\n      this.indices = this.index.array;\n      if (this.generateUVs) {\n        this.uvs = this.uvsAttribute.array;\n      }\n    }\n    updateMesh(time) {\n      this.fillMesh(time);\n      this.drawRange.count = this.currentIndex;\n      this.index.needsUpdate = true;\n      this.positionAttribute.needsUpdate = true;\n      if (this.generateUVs) {\n        this.uvsAttribute.needsUpdate = true;\n      }\n    }\n    fillMesh(time) {\n      const scope = this;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.fractalRay(time, function fillVertices(segment) {\n        const subray = scope.currentSubray;\n        if (time < subray.birthTime) {\n          return;\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else if (time < subray.endPropagationTime) {\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n            scope.createPrism(segment);\n            scope.onDecideSubrayCreation(segment, scope);\n          }\n        } else if (time < subray.beginVanishingTime) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else {\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n            scope.createPrism(segment);\n          }\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      });\n    }\n    addNewSubray() {\n      return this.subrays[this.numSubrays++];\n    }\n    initSubray(subray, rayParameters) {\n      subray.pos0.copy(rayParameters.sourceOffset);\n      subray.pos1.copy(rayParameters.destOffset);\n      subray.up0.copy(rayParameters.up0);\n      subray.up1.copy(rayParameters.up1);\n      subray.radius0 = rayParameters.radius0;\n      subray.radius1 = rayParameters.radius1;\n      subray.birthTime = rayParameters.birthTime;\n      subray.deathTime = rayParameters.deathTime;\n      subray.timeScale = rayParameters.timeScale;\n      subray.roughness = rayParameters.roughness;\n      subray.straightness = rayParameters.straightness;\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n      subray.maxIterations = this.maxIterations;\n      subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n      subray.recursion = 0;\n    }\n    fractalRay(time, segmentCallback) {\n      this.time = time;\n      this.currentSegmentCallback = segmentCallback;\n      this.numSubrays = 0;\n      this.initSubray(this.addNewSubray(), this.rayParameters);\n      for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n        const subray = this.subrays[subrayIndex];\n        this.currentSubray = subray;\n        this.randomGenerator.setSeed(subray.seed);\n        subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n        subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n        const random1 = this.randomGenerator.random;\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n        this.currentSegmentIndex = 0;\n        this.isInitialSegment = true;\n        const segment = this.getNewSegment();\n        segment.iteration = 0;\n        segment.pos0.copy(subray.pos0);\n        segment.pos1.copy(subray.pos1);\n        segment.linPos0.copy(subray.linPos0);\n        segment.linPos1.copy(subray.linPos1);\n        segment.up0.copy(subray.up0);\n        segment.up1.copy(subray.up1);\n        segment.radius0 = subray.radius0;\n        segment.radius1 = subray.radius1;\n        segment.fraction0 = 0;\n        segment.fraction1 = 1;\n        segment.positionVariationFactor = 1 - subray.straightness;\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n        this.fractalRayRecursive(segment);\n      }\n      this.currentSegmentCallback = null;\n      this.currentSubray = null;\n    }\n    fractalRayRecursive(segment) {\n      if (segment.iteration >= this.currentSubray.maxIterations) {\n        this.currentSegmentCallback(segment);\n        return;\n      }\n      this.forwards.subVectors(segment.pos1, segment.pos0);\n      let lForwards = this.forwards.length();\n      if (lForwards < 1e-6) {\n        this.forwards.set(0, 0, 0.01);\n        lForwards = this.forwards.length();\n      }\n      const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n      const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n      const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n      const p = this.middleLinPos;\n      this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n      this.newPos.add(this.middlePos);\n      const newSegment1 = this.getNewSegment();\n      newSegment1.pos0.copy(segment.pos0);\n      newSegment1.pos1.copy(this.newPos);\n      newSegment1.linPos0.copy(segment.linPos0);\n      newSegment1.linPos1.copy(this.middleLinPos);\n      newSegment1.up0.copy(segment.up0);\n      newSegment1.up1.copy(segment.up1);\n      newSegment1.radius0 = segment.radius0;\n      newSegment1.radius1 = middleRadius;\n      newSegment1.fraction0 = segment.fraction0;\n      newSegment1.fraction1 = middleFraction;\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment1.iteration = segment.iteration + 1;\n      const newSegment2 = this.getNewSegment();\n      newSegment2.pos0.copy(this.newPos);\n      newSegment2.pos1.copy(segment.pos1);\n      newSegment2.linPos0.copy(this.middleLinPos);\n      newSegment2.linPos1.copy(segment.linPos1);\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n      newSegment2.up1.copy(segment.up1);\n      newSegment2.radius0 = middleRadius;\n      newSegment2.radius1 = segment.radius1;\n      newSegment2.fraction0 = middleFraction;\n      newSegment2.fraction1 = segment.fraction1;\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment2.iteration = segment.iteration + 1;\n      this.fractalRayRecursive(newSegment1);\n      this.fractalRayRecursive(newSegment2);\n    }\n    createPrism(segment) {\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n      if (this.isInitialSegment) {\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n        this.isInitialSegment = false;\n      }\n      this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n      this.createPrismFaces();\n    }\n    createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      const p = this.vPos;\n      const v = this.vertices;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      this.currentVertex += 3;\n    }\n    createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      const p = this.vPos;\n      const v = this.vertices;\n      const uv = this.uvs;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0.5;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 1;\n      this.currentVertex += 3;\n    }\n    createPrismFaces(vertex) {\n      const indices = this.indices;\n      vertex = this.currentVertex - 6;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 5;\n    }\n    createDefaultSubrayCreationCallbacks() {\n      const random1 = this.randomGenerator.random;\n      this.onDecideSubrayCreation = function (segment, lightningStrike) {\n        const subray = lightningStrike.currentSubray;\n        const period = lightningStrike.rayParameters.subrayPeriod;\n        const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n        const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n        const phase = lightningStrike.time - phase0;\n        const currentCycle = Math.floor(phase / period);\n        const childSubraySeed = random1() * (currentCycle + 1);\n        const isActive = phase % period <= dutyCycle * period;\n        let probability = 0;\n        if (isActive) {\n          probability = lightningStrike.subrayProbability;\n        }\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n          const childSubray = lightningStrike.addNewSubray();\n          const parentSeed = lightningStrike.randomGenerator.getSeed();\n          childSubray.seed = childSubraySeed;\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\n          childSubray.recursion = subray.recursion + 1;\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.up0.copy(subray.up0);\n          childSubray.up1.copy(subray.up1);\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n          childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n          childSubray.birthTime = phase0 + currentCycle * period;\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n          }\n          childSubray.timeScale = subray.timeScale * 2;\n          childSubray.roughness = subray.roughness;\n          childSubray.straightness = subray.straightness;\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n          lightningStrike.randomGenerator.setSeed(parentSeed);\n        }\n      };\n      const vec1Pos = new Vector3();\n      const vec2Forward = new Vector3();\n      const vec3Side = new Vector3();\n      const vec4Up = new Vector3();\n      this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n      };\n      this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n        const length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        const angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n      this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n        const length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        const angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n    }\n    createSubray() {\n      return {\n        seed: 0,\n        maxIterations: 0,\n        recursion: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        birthTime: 0,\n        deathTime: 0,\n        timeScale: 0,\n        roughness: 0,\n        straightness: 0,\n        propagationTimeFactor: 0,\n        vanishingTimeFactor: 0,\n        endPropagationTime: 0,\n        beginVanishingTime: 0\n      };\n    }\n    createSegment() {\n      return {\n        iteration: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        fraction0: 0,\n        fraction1: 0,\n        positionVariationFactor: 0\n      };\n    }\n    getNewSegment() {\n      return this.raySegments[this.currentSegmentIndex++];\n    }\n    copy(source) {\n      super.copy(source);\n      this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n      return this;\n    }\n    clone() {\n      return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n    }\n  };\n  let LightningStrike2 = _LightningStrike;\n  // Ray states\n  __publicField(LightningStrike2, \"RAY_INITIALIZED\", 0);\n  __publicField(LightningStrike2, \"RAY_UNBORN\", 1);\n  __publicField(LightningStrike2, \"RAY_PROPAGATING\", 2);\n  __publicField(LightningStrike2, \"RAY_STEADY\", 3);\n  __publicField(LightningStrike2, \"RAY_VANISHING\", 4);\n  __publicField(LightningStrike2, \"RAY_EXTINGUISHED\", 5);\n  __publicField(LightningStrike2, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n  __publicField(LightningStrike2, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\n  return LightningStrike2;\n})();\nexport { LightningStrike };\n//# sourceMappingURL=LightningStrike.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}