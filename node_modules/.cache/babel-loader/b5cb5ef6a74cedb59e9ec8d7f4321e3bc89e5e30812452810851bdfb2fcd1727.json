{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useLoader, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { version } from '../helpers/constants.js';\nconst SplatMaterial = /* @__PURE__ */shaderMaterial({\n  alphaTest: 0,\n  viewport: /* @__PURE__ */new THREE.Vector2(1980, 1080),\n  focal: 1000.0,\n  centerAndScaleTexture: null,\n  covAndColorTexture: null\n}, /*glsl*/`\n    precision highp sampler2D;\n    precision highp usampler2D;\n    out vec4 vColor;\n    out vec3 vPosition;\n    uniform vec2 resolution;\n    uniform vec2 viewport;\n    uniform float focal;\n    attribute uint splatIndex;\n    uniform sampler2D centerAndScaleTexture;\n    uniform usampler2D covAndColorTexture;    \n\n    vec2 unpackInt16(in uint value) {\n      int v = int(value);\n      int v0 = v >> 16;\n      int v1 = (v & 0xFFFF);\n      if((v & 0x8000) != 0)\n        v1 |= 0xFFFF0000;\n      return vec2(float(v1), float(v0));\n    }\n\n    void main () {\n      ivec2 texSize = textureSize(centerAndScaleTexture, 0);\n      ivec2 texPos = ivec2(splatIndex%uint(texSize.x), splatIndex/uint(texSize.x));\n      vec4 centerAndScaleData = texelFetch(centerAndScaleTexture, texPos, 0);\n      vec4 center = vec4(centerAndScaleData.xyz, 1);\n      vec4 camspace = modelViewMatrix * center;\n      vec4 pos2d = projectionMatrix * camspace;\n\n      float bounds = 1.2 * pos2d.w;\n      if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds\n        || pos2d.y < -bounds || pos2d.y > bounds) {\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n        return;\n      }\n\n      uvec4 covAndColorData = texelFetch(covAndColorTexture, texPos, 0);\n      vec2 cov3D_M11_M12 = unpackInt16(covAndColorData.x) * centerAndScaleData.w;\n      vec2 cov3D_M13_M22 = unpackInt16(covAndColorData.y) * centerAndScaleData.w;\n      vec2 cov3D_M23_M33 = unpackInt16(covAndColorData.z) * centerAndScaleData.w;\n      mat3 Vrk = mat3(\n        cov3D_M11_M12.x, cov3D_M11_M12.y, cov3D_M13_M22.x,\n        cov3D_M11_M12.y, cov3D_M13_M22.y, cov3D_M23_M33.x,\n        cov3D_M13_M22.x, cov3D_M23_M33.x, cov3D_M23_M33.y\n      );\n\n      mat3 J = mat3(\n        focal / camspace.z, 0., -(focal * camspace.x) / (camspace.z * camspace.z),\n        0., focal / camspace.z, -(focal * camspace.y) / (camspace.z * camspace.z),\n        0., 0., 0.\n      );\n\n      mat3 W = transpose(mat3(modelViewMatrix));\n      mat3 T = W * J;\n      mat3 cov = transpose(T) * Vrk * T;\n      vec2 vCenter = vec2(pos2d) / pos2d.w;\n      float diagonal1 = cov[0][0] + 0.3;\n      float offDiagonal = cov[0][1];\n      float diagonal2 = cov[1][1] + 0.3;\n      float mid = 0.5 * (diagonal1 + diagonal2);\n      float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n      float lambda1 = mid + radius;\n      float lambda2 = max(mid - radius, 0.1);\n      vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n      vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n      vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n      uint colorUint = covAndColorData.w;\n      vColor = vec4(\n        float(colorUint & uint(0xFF)) / 255.0,\n        float((colorUint >> uint(8)) & uint(0xFF)) / 255.0,\n        float((colorUint >> uint(16)) & uint(0xFF)) / 255.0,\n        float(colorUint >> uint(24)) / 255.0\n      );\n      vPosition = position;\n\n      gl_Position = vec4(\n        vCenter \n          + position.x * v2 / viewport * 2.0 \n          + position.y * v1 / viewport * 2.0, pos2d.z / pos2d.w, 1.0);\n    }\n    `, /*glsl*/`\n    #include <alphatest_pars_fragment>\n    #include <alphahash_pars_fragment>\n    in vec4 vColor;\n    in vec3 vPosition;\n    void main () {\n      float A = -dot(vPosition.xy, vPosition.xy);\n      if (A < -4.0) discard;\n      float B = exp(A) * vColor.a;\n      vec4 diffuseColor = vec4(vColor.rgb, B);\n      #include <alphatest_fragment>\n      #include <alphahash_fragment>\n      gl_FragColor = diffuseColor;\n      #include <tonemapping_fragment>\n      #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n    }\n  `);\nfunction createWorker(self) {\n  let matrices = null;\n  let offset = 0;\n  function sortSplats(view, hashed = false) {\n    const vertexCount = matrices.length / 16;\n    const threshold = -0.0001;\n    let maxDepth = -Infinity;\n    let minDepth = Infinity;\n    const depthList = new Float32Array(vertexCount);\n    const sizeList = new Int32Array(depthList.buffer);\n    const validIndexList = new Int32Array(vertexCount);\n    let validCount = 0;\n    for (let i = 0; i < vertexCount; i++) {\n      // Sign of depth is reversed\n      const depth = view[0] * matrices[i * 16 + 12] + view[1] * matrices[i * 16 + 13] + view[2] * matrices[i * 16 + 14] + view[3];\n      // Skip behind of camera and small, transparent splat\n      if (hashed || depth < 0 && matrices[i * 16 + 15] > threshold * depth) {\n        depthList[validCount] = depth;\n        validIndexList[validCount] = i;\n        validCount++;\n        if (depth > maxDepth) maxDepth = depth;\n        if (depth < minDepth) minDepth = depth;\n      }\n    }\n\n    // This is a 16 bit single-pass counting sort\n    const depthInv = (256 * 256 - 1) / (maxDepth - minDepth);\n    const counts0 = new Uint32Array(256 * 256);\n    for (let i = 0; i < validCount; i++) {\n      sizeList[i] = (depthList[i] - minDepth) * depthInv | 0;\n      counts0[sizeList[i]]++;\n    }\n    const starts0 = new Uint32Array(256 * 256);\n    for (let i = 1; i < 256 * 256; i++) starts0[i] = starts0[i - 1] + counts0[i - 1];\n    const depthIndex = new Uint32Array(validCount);\n    for (let i = 0; i < validCount; i++) depthIndex[starts0[sizeList[i]]++] = validIndexList[i];\n    return depthIndex;\n  }\n  self.onmessage = e => {\n    if (e.data.method == 'push') {\n      if (offset === 0) matrices = new Float32Array(e.data.length);\n      const new_matrices = new Float32Array(e.data.matrices);\n      matrices.set(new_matrices, offset);\n      offset += new_matrices.length;\n    } else if (e.data.method == 'sort') {\n      if (matrices !== null) {\n        const indices = sortSplats(new Float32Array(e.data.view), e.data.hashed);\n        // @ts-ignore\n        self.postMessage({\n          indices,\n          key: e.data.key\n        }, [indices.buffer]);\n      }\n    }\n  };\n}\nclass SplatLoader extends THREE.Loader {\n  constructor(...args) {\n    super(...args);\n    // WebGLRenderer, needs to be filled out!\n    this.gl = null;\n    // Default chunk size for lazy loading\n    this.chunkSize = 25000;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const shared = {\n      gl: this.gl,\n      url: this.manager.resolveURL(url),\n      worker: new Worker(URL.createObjectURL(new Blob(['(', createWorker.toString(), ')(self)'], {\n        type: 'application/javascript'\n      }))),\n      manager: this.manager,\n      update: (target, camera, hashed) => update(camera, shared, target, hashed),\n      connect: target => connect(shared, target),\n      loading: false,\n      loaded: false,\n      loadedVertexCount: 0,\n      chunkSize: this.chunkSize,\n      totalDownloadBytes: 0,\n      numVertices: 0,\n      rowLength: 3 * 4 + 3 * 4 + 4 + 4,\n      maxVertexes: 0,\n      bufferTextureWidth: 0,\n      bufferTextureHeight: 0,\n      stream: null,\n      centerAndScaleData: null,\n      covAndColorData: null,\n      covAndColorTexture: null,\n      centerAndScaleTexture: null,\n      onProgress\n    };\n    load(shared).then(onLoad).catch(e => {\n      onError == null || onError(e);\n      shared.manager.itemError(shared.url);\n    });\n  }\n}\nasync function load(shared) {\n  shared.manager.itemStart(shared.url);\n  const data = await fetch(shared.url);\n  if (data.body === null) throw 'Failed to fetch file';\n  let _totalDownloadBytes = data.headers.get('Content-Length');\n  const totalDownloadBytes = _totalDownloadBytes ? parseInt(_totalDownloadBytes) : undefined;\n  if (totalDownloadBytes == undefined) throw 'Failed to get content length';\n  shared.stream = data.body.getReader();\n  shared.totalDownloadBytes = totalDownloadBytes;\n  shared.numVertices = Math.floor(shared.totalDownloadBytes / shared.rowLength);\n  const context = shared.gl.getContext();\n  let maxTextureSize = context.getParameter(context.MAX_TEXTURE_SIZE);\n  shared.maxVertexes = maxTextureSize * maxTextureSize;\n  if (shared.numVertices > shared.maxVertexes) shared.numVertices = shared.maxVertexes;\n  shared.bufferTextureWidth = maxTextureSize;\n  shared.bufferTextureHeight = Math.floor((shared.numVertices - 1) / maxTextureSize) + 1;\n  shared.centerAndScaleData = new Float32Array(shared.bufferTextureWidth * shared.bufferTextureHeight * 4);\n  shared.covAndColorData = new Uint32Array(shared.bufferTextureWidth * shared.bufferTextureHeight * 4);\n  shared.centerAndScaleTexture = new THREE.DataTexture(shared.centerAndScaleData, shared.bufferTextureWidth, shared.bufferTextureHeight, THREE.RGBAFormat, THREE.FloatType);\n  shared.centerAndScaleTexture.needsUpdate = true;\n  shared.covAndColorTexture = new THREE.DataTexture(shared.covAndColorData, shared.bufferTextureWidth, shared.bufferTextureHeight, THREE.RGBAIntegerFormat, THREE.UnsignedIntType);\n  shared.covAndColorTexture.internalFormat = 'RGBA32UI';\n  shared.covAndColorTexture.needsUpdate = true;\n  return shared;\n}\nasync function lazyLoad(shared) {\n  shared.loading = true;\n  let bytesDownloaded = 0;\n  let bytesProcessed = 0;\n  const chunks = [];\n  let lastReportedProgress = 0;\n  const lengthComputable = shared.totalDownloadBytes !== 0;\n  while (true) {\n    try {\n      const {\n        value,\n        done\n      } = await shared.stream.read();\n      if (done) break;\n      bytesDownloaded += value.length;\n      if (shared.totalDownloadBytes != undefined) {\n        const percent = bytesDownloaded / shared.totalDownloadBytes * 100;\n        if (shared.onProgress && percent - lastReportedProgress > 1) {\n          const event = new ProgressEvent('progress', {\n            lengthComputable,\n            loaded: bytesDownloaded,\n            total: shared.totalDownloadBytes\n          });\n          shared.onProgress(event);\n          lastReportedProgress = percent;\n        }\n      }\n      chunks.push(value);\n      const bytesRemains = bytesDownloaded - bytesProcessed;\n      if (shared.totalDownloadBytes != undefined && bytesRemains > shared.rowLength * shared.chunkSize) {\n        let vertexCount = Math.floor(bytesRemains / shared.rowLength);\n        const concatenatedChunksbuffer = new Uint8Array(bytesRemains);\n        let offset = 0;\n        for (const chunk of chunks) {\n          concatenatedChunksbuffer.set(chunk, offset);\n          offset += chunk.length;\n        }\n        chunks.length = 0;\n        if (bytesRemains > vertexCount * shared.rowLength) {\n          const extra_data = new Uint8Array(bytesRemains - vertexCount * shared.rowLength);\n          extra_data.set(concatenatedChunksbuffer.subarray(bytesRemains - extra_data.length, bytesRemains), 0);\n          chunks.push(extra_data);\n        }\n        const buffer = new Uint8Array(vertexCount * shared.rowLength);\n        buffer.set(concatenatedChunksbuffer.subarray(0, buffer.byteLength), 0);\n        const matrices = pushDataBuffer(shared, buffer.buffer, vertexCount);\n        shared.worker.postMessage({\n          method: 'push',\n          src: shared.url,\n          length: shared.numVertices * 16,\n          matrices: matrices.buffer\n        }, [matrices.buffer]);\n        bytesProcessed += vertexCount * shared.rowLength;\n        if (shared.onProgress) {\n          const event = new ProgressEvent('progress', {\n            lengthComputable,\n            loaded: shared.totalDownloadBytes,\n            total: shared.totalDownloadBytes\n          });\n          shared.onProgress(event);\n        }\n      }\n    } catch (error) {\n      console.error(error);\n      break;\n    }\n  }\n  if (bytesDownloaded - bytesProcessed > 0) {\n    // Concatenate the chunks into a single Uint8Array\n    let concatenatedChunks = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));\n    let offset = 0;\n    for (const chunk of chunks) {\n      concatenatedChunks.set(chunk, offset);\n      offset += chunk.length;\n    }\n    let numVertices = Math.floor(concatenatedChunks.byteLength / shared.rowLength);\n    const matrices = pushDataBuffer(shared, concatenatedChunks.buffer, numVertices);\n    shared.worker.postMessage({\n      method: 'push',\n      src: shared.url,\n      length: numVertices * 16,\n      matrices: matrices.buffer\n    }, [matrices.buffer]);\n  }\n  shared.loaded = true;\n  shared.manager.itemEnd(shared.url);\n}\nfunction update(camera, shared, target, hashed) {\n  camera.updateMatrixWorld();\n  shared.gl.getCurrentViewport(target.viewport);\n  // @ts-ignore\n  target.material.viewport.x = target.viewport.z;\n  // @ts-ignore\n  target.material.viewport.y = target.viewport.w;\n  target.material.focal = target.viewport.w / 2.0 * Math.abs(camera.projectionMatrix.elements[5]);\n  if (target.ready) {\n    if (hashed && target.sorted) return;\n    target.ready = false;\n    const view = new Float32Array([target.modelViewMatrix.elements[2], -target.modelViewMatrix.elements[6], target.modelViewMatrix.elements[10], target.modelViewMatrix.elements[14]]);\n    shared.worker.postMessage({\n      method: 'sort',\n      src: shared.url,\n      key: target.uuid,\n      view: view.buffer,\n      hashed\n    }, [view.buffer]);\n    if (hashed && shared.loaded) target.sorted = true;\n  }\n}\nfunction connect(shared, target) {\n  if (!shared.loading) lazyLoad(shared);\n  target.ready = false;\n  target.pm = new THREE.Matrix4();\n  target.vm1 = new THREE.Matrix4();\n  target.vm2 = new THREE.Matrix4();\n  target.viewport = new THREE.Vector4();\n  let splatIndexArray = new Uint32Array(shared.bufferTextureWidth * shared.bufferTextureHeight);\n  const splatIndexes = new THREE.InstancedBufferAttribute(splatIndexArray, 1, false);\n  splatIndexes.setUsage(THREE.DynamicDrawUsage);\n  const geometry = target.geometry = new THREE.InstancedBufferGeometry();\n  const positionsArray = new Float32Array(6 * 3);\n  const positions = new THREE.BufferAttribute(positionsArray, 3);\n  geometry.setAttribute('position', positions);\n  positions.setXYZ(2, -2.0, 2.0, 0.0);\n  positions.setXYZ(1, 2.0, 2.0, 0.0);\n  positions.setXYZ(0, -2.0, -2.0, 0.0);\n  positions.setXYZ(5, -2.0, -2.0, 0.0);\n  positions.setXYZ(4, 2.0, 2.0, 0.0);\n  positions.setXYZ(3, 2.0, -2.0, 0.0);\n  positions.needsUpdate = true;\n  geometry.setAttribute('splatIndex', splatIndexes);\n  geometry.instanceCount = 1;\n  function listener(e) {\n    if (target && e.data.key === target.uuid) {\n      let indexes = new Uint32Array(e.data.indices);\n      // @ts-ignore\n      geometry.attributes.splatIndex.set(indexes);\n      geometry.attributes.splatIndex.needsUpdate = true;\n      geometry.instanceCount = indexes.length;\n      target.ready = true;\n    }\n  }\n  shared.worker.addEventListener('message', listener);\n  async function wait() {\n    while (true) {\n      const centerAndScaleTextureProperties = shared.gl.properties.get(shared.centerAndScaleTexture);\n      const covAndColorTextureProperties = shared.gl.properties.get(shared.covAndColorTexture);\n      if (centerAndScaleTextureProperties != null && centerAndScaleTextureProperties.__webglTexture && covAndColorTextureProperties != null && covAndColorTextureProperties.__webglTexture && shared.loadedVertexCount > 0) break;\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n    target.ready = true;\n  }\n  wait();\n  return () => shared.worker.removeEventListener('message', listener);\n}\nfunction pushDataBuffer(shared, buffer, vertexCount) {\n  const context = shared.gl.getContext();\n  if (shared.loadedVertexCount + vertexCount > shared.maxVertexes) vertexCount = shared.maxVertexes - shared.loadedVertexCount;\n  if (vertexCount <= 0) throw 'Failed to parse file';\n  const u_buffer = new Uint8Array(buffer);\n  const f_buffer = new Float32Array(buffer);\n  const matrices = new Float32Array(vertexCount * 16);\n  const covAndColorData_uint8 = new Uint8Array(shared.covAndColorData.buffer);\n  const covAndColorData_int16 = new Int16Array(shared.covAndColorData.buffer);\n  for (let i = 0; i < vertexCount; i++) {\n    const quat = new THREE.Quaternion(-(u_buffer[32 * i + 28 + 1] - 128) / 128.0, (u_buffer[32 * i + 28 + 2] - 128) / 128.0, (u_buffer[32 * i + 28 + 3] - 128) / 128.0, -(u_buffer[32 * i + 28 + 0] - 128) / 128.0);\n    quat.invert();\n    const center = new THREE.Vector3(f_buffer[8 * i + 0], f_buffer[8 * i + 1], -f_buffer[8 * i + 2]);\n    const scale = new THREE.Vector3(f_buffer[8 * i + 3 + 0], f_buffer[8 * i + 3 + 1], f_buffer[8 * i + 3 + 2]);\n    const mtx = new THREE.Matrix4();\n    mtx.makeRotationFromQuaternion(quat);\n    mtx.transpose();\n    mtx.scale(scale);\n    const mtx_t = mtx.clone();\n    mtx.transpose();\n    mtx.premultiply(mtx_t);\n    mtx.setPosition(center);\n    const cov_indexes = [0, 1, 2, 5, 6, 10];\n    let max_value = 0.0;\n    for (let j = 0; j < cov_indexes.length; j++) if (Math.abs(mtx.elements[cov_indexes[j]]) > max_value) max_value = Math.abs(mtx.elements[cov_indexes[j]]);\n    let destOffset = shared.loadedVertexCount * 4 + i * 4;\n    shared.centerAndScaleData[destOffset + 0] = center.x;\n    shared.centerAndScaleData[destOffset + 1] = -center.y;\n    shared.centerAndScaleData[destOffset + 2] = center.z;\n    shared.centerAndScaleData[destOffset + 3] = max_value / 32767.0;\n    destOffset = shared.loadedVertexCount * 8 + i * 4 * 2;\n    for (let j = 0; j < cov_indexes.length; j++) covAndColorData_int16[destOffset + j] = mtx.elements[cov_indexes[j]] * 32767.0 / max_value;\n\n    // RGBA\n    destOffset = shared.loadedVertexCount * 16 + (i * 4 + 3) * 4;\n    const col = new THREE.Color(u_buffer[32 * i + 24 + 0] / 255, u_buffer[32 * i + 24 + 1] / 255, u_buffer[32 * i + 24 + 2] / 255);\n    col.convertSRGBToLinear();\n    covAndColorData_uint8[destOffset + 0] = col.r * 255;\n    covAndColorData_uint8[destOffset + 1] = col.g * 255;\n    covAndColorData_uint8[destOffset + 2] = col.b * 255;\n    covAndColorData_uint8[destOffset + 3] = u_buffer[32 * i + 24 + 3];\n\n    // Store scale and transparent to remove splat in sorting process\n    mtx.elements[15] = Math.max(scale.x, scale.y, scale.z) * u_buffer[32 * i + 24 + 3] / 255.0;\n    for (let j = 0; j < 16; j++) matrices[i * 16 + j] = mtx.elements[j];\n  }\n  while (vertexCount > 0) {\n    let width = 0;\n    let height = 0;\n    const xoffset = shared.loadedVertexCount % shared.bufferTextureWidth;\n    const yoffset = Math.floor(shared.loadedVertexCount / shared.bufferTextureWidth);\n    if (shared.loadedVertexCount % shared.bufferTextureWidth != 0) {\n      width = Math.min(shared.bufferTextureWidth, xoffset + vertexCount) - xoffset;\n      height = 1;\n    } else if (Math.floor(vertexCount / shared.bufferTextureWidth) > 0) {\n      width = shared.bufferTextureWidth;\n      height = Math.floor(vertexCount / shared.bufferTextureWidth);\n    } else {\n      width = vertexCount % shared.bufferTextureWidth;\n      height = 1;\n    }\n    const centerAndScaleTextureProperties = shared.gl.properties.get(shared.centerAndScaleTexture);\n    context.bindTexture(context.TEXTURE_2D, centerAndScaleTextureProperties.__webglTexture);\n    context.texSubImage2D(context.TEXTURE_2D, 0, xoffset, yoffset, width, height, context.RGBA, context.FLOAT, shared.centerAndScaleData, shared.loadedVertexCount * 4);\n    const covAndColorTextureProperties = shared.gl.properties.get(shared.covAndColorTexture);\n    context.bindTexture(context.TEXTURE_2D, covAndColorTextureProperties.__webglTexture);\n    context.texSubImage2D(context.TEXTURE_2D, 0, xoffset, yoffset, width, height,\n    // @ts-ignore\n    context.RGBA_INTEGER, context.UNSIGNED_INT, shared.covAndColorData, shared.loadedVertexCount * 4);\n    shared.gl.resetState();\n    shared.loadedVertexCount += width * height;\n    vertexCount -= width * height;\n  }\n  return matrices;\n}\nfunction Splat({\n  src,\n  toneMapped = false,\n  alphaTest = 0,\n  alphaHash = false,\n  chunkSize = 25000,\n  ...props\n}) {\n  extend({\n    SplatMaterial\n  });\n  const ref = React.useRef(null);\n  const gl = useThree(state => state.gl);\n  const camera = useThree(state => state.camera);\n\n  // Shared state, globally memoized, the same url re-uses the same daza\n  const shared = useLoader(SplatLoader, src, loader => {\n    loader.gl = gl;\n    loader.chunkSize = chunkSize;\n  });\n\n  // Listen to worker results, apply them to the target mesh\n  React.useLayoutEffect(() => shared.connect(ref.current), [src]);\n  // Update the worker\n  useFrame(() => shared.update(ref.current, camera, alphaHash));\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: ref,\n    frustumCulled: false\n  }, props), /*#__PURE__*/React.createElement(\"splatMaterial\", {\n    key: `${src}/${alphaTest}/${alphaHash}${SplatMaterial.key}`,\n    transparent: !alphaHash,\n    depthTest: true,\n    alphaTest: alphaHash ? 0 : alphaTest,\n    centerAndScaleTexture: shared.centerAndScaleTexture,\n    covAndColorTexture: shared.covAndColorTexture,\n    depthWrite: alphaHash ? true : alphaTest > 0,\n    blending: alphaHash ? THREE.NormalBlending : THREE.CustomBlending,\n    blendSrcAlpha: THREE.OneFactor,\n    alphaHash: !!alphaHash,\n    toneMapped: toneMapped\n  }));\n}\nexport { Splat };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}