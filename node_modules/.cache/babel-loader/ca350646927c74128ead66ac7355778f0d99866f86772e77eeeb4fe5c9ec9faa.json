{"ast":null,"code":"import { Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, Vector3, BufferGeometry, BufferAttribute, LineSegments, Mesh, Ray, Matrix4, Group } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = \"16\";\nconst MAIN_EDGE_COLOUR_CODE = \"24\";\nconst _tempVec0 = /* @__PURE__ */new Vector3();\nconst _tempVec1 = /* @__PURE__ */new Vector3();\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: (/* glsl */\n      `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `),\n      fragmentShader: (/* glsl */\n      `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `)\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n}\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n}\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nconst _ray = /* @__PURE__ */new Ray();\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  const hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  const hardEdges = /* @__PURE__ */new Set();\n  const hardEdgeRays = /* @__PURE__ */new Map();\n  const halfEdgeList = {};\n  const normals = [];\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info2 = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        [d0, d1] = [d1, d0];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          const info2 = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info2;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n          if (d0 > d1) {\n            [d0, d1] = [d1, d0];\n          }\n          let found = false;\n          for (let i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (d0 >= distances[i3] && d1 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      const info = {\n        index,\n        tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  }\n  while (true) {\n    let halfEdge = null;\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    const queue = [halfEdge];\n    while (queue.length > 0) {\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal;\n      const vertCount = vertices.length;\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next];\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          const otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n        return;\n      }\n      this.currentCharIndex++;\n    }\n  }\n  getToken() {\n    const pos0 = this.currentCharIndex++;\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n      if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n        break;\n      }\n      this.currentCharIndex++;\n    }\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n  }\n}\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n  cloneResult(original) {\n    const result = {};\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    });\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = \"parts/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = \"p/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = \"models/\" + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n          break;\n      }\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch (e) {\n        continue;\n      }\n    }\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n  parse(text, fileName = null) {\n    const loader = this.loader;\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n    let type = \"Model\";\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0;\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    const lines = text.split(\"\\n\");\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false;\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith(\"0 FILE \")) {\n          this.setData(currentEmbeddedFileName, currentEmbeddedText);\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = \"\";\n        } else {\n          currentEmbeddedText += line + \"\\n\";\n        }\n        continue;\n      }\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n      if (lp.isAtTheEnd()) {\n        continue;\n      }\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n      switch (lineType) {\n        case \"0\":\n          const meta = lp.getToken();\n          if (meta) {\n            switch (meta) {\n              case \"!LDRAW_ORG\":\n                type = lp.getToken();\n                break;\n              case \"!COLOUR\":\n                material = loader.parseColorMetaDirective(lp);\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                }\n                break;\n              case \"!CATEGORY\":\n                category = lp.getToken();\n                break;\n              case \"!KEYWORDS\":\n                const newKeywords = lp.getRemainingString().split(\",\");\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n                break;\n              case \"FILE\":\n                if (lineIndex > 0) {\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = \"\";\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n                break;\n              case \"BFC\":\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n                  switch (token) {\n                    case \"CERTIFY\":\n                    case \"NOCERTIFY\":\n                      bfcCertified = token === \"CERTIFY\";\n                      bfcCCW = true;\n                      break;\n                    case \"CW\":\n                    case \"CCW\":\n                      bfcCCW = token === \"CCW\";\n                      break;\n                    case \"INVERTNEXT\":\n                      bfcInverted = true;\n                      break;\n                    case \"CLIP\":\n                    case \"NOCLIP\":\n                      bfcCull = token === \"CLIP\";\n                      break;\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n                break;\n              case \"STEP\":\n                startingConstructionStep = true;\n                break;\n            }\n          }\n          break;\n        case \"1\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n          if (loader.fileMap[fileName2]) {\n            fileName2 = loader.fileMap[fileName2];\n          } else {\n            if (fileName2.startsWith(\"s/\")) {\n              fileName2 = \"parts/\" + fileName2;\n            } else if (fileName2.startsWith(\"48/\")) {\n              fileName2 = \"p/\" + fileName2;\n            }\n          }\n          subobjects.push({\n            material,\n            colorCode,\n            matrix,\n            fileName: fileName2,\n            inverted: bfcInverted,\n            startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        case \"2\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        case \"5\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material,\n            colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        case \"3\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n          break;\n        case \"4\":\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n          faces.push({\n            material,\n            colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n          if (doubleSided === true) {\n            faces.push({\n              material,\n              colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n      }\n    }\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  }\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  }\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n    if (!(key in this._cache)) {\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n    await this._cache[key];\n  }\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n}\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = /* @__PURE__ */new Set();\n    const processInfoSubobjects = async (info2, subobject = null) => {\n      const subobjects = info2.subobjects;\n      const promises = [];\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject2 = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject2.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject2.fileName, false);\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject2.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n          return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n        });\n        promises.push(promise);\n      }\n      const group2 = new Group();\n      group2.userData.category = info2.category;\n      group2.userData.keywords = info2.keywords;\n      info2.group = group2;\n      const subobjectInfos = await Promise.all(promises);\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject2 = info2.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n        if (subobjectInfo === null) {\n          continue;\n        }\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n          subobjectGroup.name = subobject2.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n          group2.add(subobjectGroup);\n          continue;\n        }\n        if (subobjectInfo.group.children.length) {\n          group2.add(subobjectInfo.group);\n        }\n        const parentLineSegments = info2.lineSegments;\n        const parentConditionalSegments = info2.conditionalSegments;\n        const parentFaces = info2.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject2.matrix;\n        const inverted = subobject2.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject2.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n        for (let i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n          const ls = lineSegments[i2];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n          parentLineSegments.push(ls);\n        }\n        for (let i2 = 0, l2 = conditionalSegments.length; i2 < l2; i2++) {\n          const os = conditionalSegments[i2];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n          parentConditionalSegments.push(os);\n        }\n        for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {\n          const tri = faces[i2];\n          const vertices = tri.vertices;\n          for (let i3 = 0, l3 = vertices.length; i3 < l3; i3++) {\n            vertices[i3].applyMatrix4(matrix);\n          }\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n          faceMaterials.add(tri.colorCode);\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n          parentFaces.push(tri);\n        }\n        info2.totalFaces += subobjectInfo.totalFaces;\n      }\n      if (subobject) {\n        loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n      }\n      return info2;\n    };\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n    await processInfoSubobjects(info);\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    }\n    const group = info.group;\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n    return group;\n  }\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  }\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n    if (this.hasCachedModel(fileName)) {\n      return this.getCachedModel(fileName);\n    } else {\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info);\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      }\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      }\n      const group = await promise;\n      return group.clone();\n    }\n  }\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n    return this.processIntoMesh(info);\n  }\n}\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      let elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        let n = elem.faceNormal;\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      const material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  let object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = [];\n    this.materialLibrary = {};\n    this.partsCache = new LDrawPartsGeometryCache(this);\n    this.fileMap = {};\n    this.setMaterials([]);\n    this.smoothNormals = true;\n    this.partsLibraryPath = \"\";\n  }\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, \"\");\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n    this.setMaterials(materials);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeConstructionSteps(group);\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    }\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n    return this;\n  }\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n  addMaterial(material) {\n    const matLib = this.materialLibrary;\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n    return this;\n  }\n  getMaterial(colorCode) {\n    if (colorCode.startsWith(\"0x2\")) {\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color));\n    }\n    return this.materialLibrary[colorCode] || null;\n  }\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    });\n    function getMaterial(c, colorCode) {\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n      let material = null;\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        material = loader.getMaterial(colorCode);\n        if (material === null) {\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n      return material;\n    }\n  }\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n  parseColorMetaDirective(lineParser) {\n    let code = null;\n    let color = 16711935;\n    let edgeColor = 16711935;\n    let alpha = 1;\n    let isTransparent = false;\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n    }\n    let token = null;\n    while (true) {\n      token = lineParser.getToken();\n      if (!token) {\n        break;\n      }\n      switch (token.toUpperCase()) {\n        case \"CODE\":\n          code = lineParser.getToken();\n          break;\n        case \"VALUE\":\n          color = lineParser.getToken();\n          if (color.startsWith(\"0x\")) {\n            color = \"#\" + color.substring(2);\n          } else if (!color.startsWith(\"#\")) {\n            throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n          }\n          break;\n        case \"EDGE\":\n          edgeColor = lineParser.getToken();\n          if (edgeColor.startsWith(\"0x\")) {\n            edgeColor = \"#\" + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith(\"#\")) {\n            edgeMaterial = this.getMaterial(edgeColor);\n            if (!edgeMaterial) {\n              throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n            }\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n          break;\n        case \"ALPHA\":\n          alpha = parseInt(lineParser.getToken());\n          if (isNaN(alpha)) {\n            throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n          }\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n          break;\n        case \"LUMINANCE\":\n          luminance = parseInt(lineParser.getToken());\n          if (isNaN(luminance)) {\n            throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\");\n          }\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n        case \"CHROME\":\n          finishType = FINISH_TYPE_CHROME;\n          break;\n        case \"PEARLESCENT\":\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n        case \"RUBBER\":\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n        case \"MATTE_METALLIC\":\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n        case \"METAL\":\n          finishType = FINISH_TYPE_METAL;\n          break;\n        case \"MATERIAL\":\n          lineParser.setToEnd();\n          break;\n        default:\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n      }\n    }\n    let material = null;\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_PEARLESCENT:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n      case FINISH_TYPE_CHROME:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n      case FINISH_TYPE_RUBBER:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n      case FINISH_TYPE_MATTE_METALLIC:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n      case FINISH_TYPE_METAL:\n        material = new MeshStandardMaterial({\n          color,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n    if (!edgeMaterial) {\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + \" - Edge\";\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n  computeConstructionSteps(model) {\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n}\nexport { LDrawLoader };\n//# sourceMappingURL=LDrawLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}