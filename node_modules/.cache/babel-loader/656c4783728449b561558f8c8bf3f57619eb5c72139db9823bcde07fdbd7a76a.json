{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Matrix4, Vector2, Color, Vector3, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane, HalfFloatType } from \"three\";\nconst ReflectorForSSRPass = /* @__PURE__ */(() => {\n  const _ReflectorForSSRPass = class extends Mesh {\n    constructor(geometry, options = {}) {\n      super(geometry);\n      this.isReflectorForSSRPass = true;\n      this.type = \"ReflectorForSSRPass\";\n      const scope = this;\n      const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n      const textureWidth = options.textureWidth || 512;\n      const textureHeight = options.textureHeight || 512;\n      const clipBias = options.clipBias || 0;\n      const shader = options.shader || _ReflectorForSSRPass.ReflectorShader;\n      const useDepthTexture = options.useDepthTexture === true;\n      const yAxis = new Vector3(0, 1, 0);\n      const vecTemp0 = new Vector3();\n      const vecTemp1 = new Vector3();\n      scope.needsUpdate = false;\n      scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n      scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n      scope.color = color;\n      scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n      scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n      Object.defineProperty(scope, \"distanceAttenuation\", {\n        get() {\n          return scope._distanceAttenuation;\n        },\n        set(val) {\n          if (scope._distanceAttenuation === val) return;\n          scope._distanceAttenuation = val;\n          scope.material.defines.DISTANCE_ATTENUATION = val;\n          scope.material.needsUpdate = true;\n        }\n      });\n      scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n      Object.defineProperty(scope, \"fresnel\", {\n        get() {\n          return scope._fresnel;\n        },\n        set(val) {\n          if (scope._fresnel === val) return;\n          scope._fresnel = val;\n          scope.material.defines.FRESNEL = val;\n          scope.material.needsUpdate = true;\n        }\n      });\n      const normal = new Vector3();\n      const reflectorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const lookAtPosition = new Vector3(0, 0, -1);\n      const view = new Vector3();\n      const target = new Vector3();\n      const textureMatrix = new Matrix4();\n      const virtualCamera = new PerspectiveCamera();\n      let depthTexture;\n      if (useDepthTexture) {\n        depthTexture = new DepthTexture();\n        depthTexture.type = UnsignedShortType;\n        depthTexture.minFilter = NearestFilter;\n        depthTexture.magFilter = NearestFilter;\n      }\n      const parameters = {\n        depthTexture: useDepthTexture ? depthTexture : null,\n        type: HalfFloatType\n      };\n      const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n      const material = new ShaderMaterial({\n        transparent: useDepthTexture,\n        defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {\n          useDepthTexture\n        }),\n        uniforms: UniformsUtils.clone(shader.uniforms),\n        fragmentShader: shader.fragmentShader,\n        vertexShader: shader.vertexShader\n      });\n      material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n      material.uniforms[\"color\"].value = scope.color;\n      material.uniforms[\"textureMatrix\"].value = textureMatrix;\n      if (useDepthTexture) {\n        material.uniforms[\"tDepth\"].value = renderTarget.depthTexture;\n      }\n      this.material = material;\n      const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n      const globalPlanes = [globalPlane];\n      this.doRender = function (renderer, scene, camera) {\n        material.uniforms[\"maxDistance\"].value = scope.maxDistance;\n        material.uniforms[\"color\"].value = scope.color;\n        material.uniforms[\"opacity\"].value = scope.opacity;\n        vecTemp0.copy(camera.position).normalize();\n        vecTemp1.copy(vecTemp0).reflect(yAxis);\n        material.uniforms[\"fresnelCoe\"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;\n        reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n        if (view.dot(normal) > 0) return;\n        view.reflect(normal).negate();\n        view.add(reflectorWorldPosition);\n        rotationMatrix.extractRotation(camera.matrixWorld);\n        lookAtPosition.set(0, 0, -1);\n        lookAtPosition.applyMatrix4(rotationMatrix);\n        lookAtPosition.add(cameraWorldPosition);\n        target.subVectors(reflectorWorldPosition, lookAtPosition);\n        target.reflect(normal).negate();\n        target.add(reflectorWorldPosition);\n        virtualCamera.position.copy(view);\n        virtualCamera.up.set(0, 1, 0);\n        virtualCamera.up.applyMatrix4(rotationMatrix);\n        virtualCamera.up.reflect(normal);\n        virtualCamera.lookAt(target);\n        virtualCamera.far = camera.far;\n        virtualCamera.updateMatrixWorld();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        material.uniforms[\"virtualCameraNear\"].value = camera.near;\n        material.uniforms[\"virtualCameraFar\"].value = camera.far;\n        material.uniforms[\"virtualCameraMatrixWorld\"].value = virtualCamera.matrixWorld;\n        material.uniforms[\"virtualCameraProjectionMatrix\"].value = camera.projectionMatrix;\n        material.uniforms[\"virtualCameraProjectionMatrixInverse\"].value = camera.projectionMatrixInverse;\n        material.uniforms[\"resolution\"].value = scope.resolution;\n        textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n        textureMatrix.multiply(virtualCamera.projectionMatrix);\n        textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n        textureMatrix.multiply(scope.matrixWorld);\n        const currentRenderTarget = renderer.getRenderTarget();\n        const currentXrEnabled = renderer.xr.enabled;\n        const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n        const currentClippingPlanes = renderer.clippingPlanes;\n        renderer.xr.enabled = false;\n        renderer.shadowMap.autoUpdate = false;\n        renderer.clippingPlanes = globalPlanes;\n        renderer.setRenderTarget(renderTarget);\n        renderer.state.buffers.depth.setMask(true);\n        if (renderer.autoClear === false) renderer.clear();\n        renderer.render(scene, virtualCamera);\n        renderer.xr.enabled = currentXrEnabled;\n        renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n        renderer.clippingPlanes = currentClippingPlanes;\n        renderer.setRenderTarget(currentRenderTarget);\n        const viewport = camera.viewport;\n        if (viewport !== void 0) {\n          renderer.state.viewport(viewport);\n        }\n      };\n      this.getRenderTarget = function () {\n        return renderTarget;\n      };\n    }\n  };\n  let ReflectorForSSRPass2 = _ReflectorForSSRPass;\n  __publicField(ReflectorForSSRPass2, \"ReflectorShader\", {\n    defines: {\n      DISTANCE_ATTENUATION: true,\n      FRESNEL: true\n    },\n    uniforms: {\n      color: {\n        value: null\n      },\n      tDiffuse: {\n        value: null\n      },\n      tDepth: {\n        value: null\n      },\n      textureMatrix: {\n        value: new Matrix4()\n      },\n      maxDistance: {\n        value: 180\n      },\n      opacity: {\n        value: 0.5\n      },\n      fresnelCoe: {\n        value: null\n      },\n      virtualCameraNear: {\n        value: null\n      },\n      virtualCameraFar: {\n        value: null\n      },\n      virtualCameraProjectionMatrix: {\n        value: new Matrix4()\n      },\n      virtualCameraMatrixWorld: {\n        value: new Matrix4()\n      },\n      virtualCameraProjectionMatrixInverse: {\n        value: new Matrix4()\n      },\n      resolution: {\n        value: new Vector2()\n      }\n    },\n    vertexShader: (/* glsl */\n    `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`),\n    fragmentShader: (/* glsl */\n    `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`)\n  });\n  return ReflectorForSSRPass2;\n})();\nexport { ReflectorForSSRPass };\n//# sourceMappingURL=ReflectorForSSRPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}