{"ast":null,"code":"import { Loader, FileLoader, Matrix3, Vector2, Vector3, ShapeUtils, Box2, Shape, Path, BufferGeometry, Float32BufferAttribute, ShapePath } from \"three\";\nconst COLOR_SPACE_SVG = \"srgb\";\nconst SVGLoader = /* @__PURE__ */(() => {\n  class SVGLoader2 extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.defaultDPI = 90;\n      this.defaultUnit = \"px\";\n    }\n    load(url, onLoad, onProgress, onError) {\n      const scope = this;\n      const loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n    parse(text) {\n      const scope = this;\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return;\n        const transform = getNodeTransform(node);\n        let isDefsNode = false;\n        let path = null;\n        switch (node.nodeName) {\n          case \"svg\":\n            style = parseStyle(node, style);\n            break;\n          case \"style\":\n            parseCSSStylesheet(node);\n            break;\n          case \"g\":\n            style = parseStyle(node, style);\n            break;\n          case \"path\":\n            style = parseStyle(node, style);\n            if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n            break;\n          case \"rect\":\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n          case \"polygon\":\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n          case \"polyline\":\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n          case \"circle\":\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n          case \"ellipse\":\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n          case \"line\":\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n          case \"defs\":\n            isDefsNode = true;\n            break;\n          case \"use\":\n            style = parseStyle(node, style);\n            const href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\";\n            const usedNodeId = href.substring(1);\n            const usedNode = node.viewportElement.getElementById(usedNodeId);\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n            break;\n        }\n        if (path) {\n          if (style.fill !== void 0 && style.fill !== \"none\") {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG);\n          }\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = {\n            node,\n            style\n          };\n        }\n        const childNodes = node.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n          const node2 = childNodes[i];\n          if (isDefsNode && node2.nodeName !== \"style\" && node2.nodeName !== \"defs\") {\n            continue;\n          }\n          parseNode(node2, style);\n        }\n        if (transform) {\n          transformStack.pop();\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n      function parsePathNode(node) {\n        const path = new ShapePath();\n        const point = new Vector2();\n        const control = new Vector2();\n        const firstPoint = new Vector2();\n        let isFirstPoint = true;\n        let doSetFirstPoint = false;\n        const d = node.getAttribute(\"d\");\n        if (d === \"\" || d === \"none\") return null;\n        const commands = d.match(/[a-df-z][^a-df-z]*/gi);\n        for (let i = 0, l = commands.length; i < l; i++) {\n          const command = commands[i];\n          const type = command.charAt(0);\n          const data2 = command.slice(1).trim();\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n          let numbers;\n          switch (type) {\n            case \"M\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0) firstPoint.copy(point);\n              }\n              break;\n            case \"H\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x = numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"V\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y = numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"L\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"C\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n                control.x = numbers[j + 2];\n                control.y = numbers[j + 3];\n                point.x = numbers[j + 4];\n                point.y = numbers[j + 5];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"S\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                control.x = numbers[j + 0];\n                control.y = numbers[j + 1];\n                point.x = numbers[j + 2];\n                point.y = numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"Q\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                control.x = numbers[j + 0];\n                control.y = numbers[j + 1];\n                point.x = numbers[j + 2];\n                point.y = numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"T\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x);\n                const ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"A\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n                const start = point.clone();\n                point.x = numbers[j + 5];\n                point.y = numbers[j + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"m\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0];\n                point.y += numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0) firstPoint.copy(point);\n              }\n              break;\n            case \"h\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x += numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"v\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y += numbers[j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"l\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0];\n                point.y += numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"c\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n                control.x = point.x + numbers[j + 2];\n                control.y = point.y + numbers[j + 3];\n                point.x += numbers[j + 4];\n                point.y += numbers[j + 5];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"s\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n                control.x = point.x + numbers[j + 0];\n                control.y = point.y + numbers[j + 1];\n                point.x += numbers[j + 2];\n                point.y += numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"q\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n                control.x = point.x + numbers[j + 0];\n                control.y = point.y + numbers[j + 1];\n                point.x += numbers[j + 2];\n                point.y += numbers[j + 3];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"t\":\n              numbers = parseFloats(data2);\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x);\n                const ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = point.x + numbers[j + 0];\n                point.y = point.y + numbers[j + 1];\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"a\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n                const start = point.clone();\n                point.x += numbers[j + 5];\n                point.y += numbers[j + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"Z\":\n            case \"z\":\n              path.currentPath.autoClose = true;\n              if (path.currentPath.curves.length > 0) {\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n              break;\n            default:\n              console.warn(command);\n          }\n          doSetFirstPoint = false;\n        }\n        return path;\n      }\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n        for (let i = 0; i < node.sheet.cssRules.length; i++) {\n          const stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1) continue;\n          const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i2 => i2.trim());\n          for (let j = 0; j < selectorList.length; j++) {\n            const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== \"\"));\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n          }\n        }\n      }\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          path.lineTo(end.x, end.y);\n          return;\n        }\n        x_axis_rotation = x_axis_rotation * Math.PI / 180;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        const dx2 = (start.x - end.x) / 2;\n        const dy2 = (start.y - end.y) / 2;\n        const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n        let rxs = rx * rx;\n        let rys = ry * ry;\n        const x1ps = x1p * x1p;\n        const y1ps = y1p * y1p;\n        const cr = x1ps / rxs + y1ps / rys;\n        if (cr > 1) {\n          const s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n        const dq = rxs * y1ps + rys * x1ps;\n        const pq = (rxs * rys - dq) / dq;\n        let q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag) q = -q;\n        const cxp = q * rx * y1p / ry;\n        const cyp = -q * ry * x1p / rx;\n        const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n        const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n      function svgAngle(ux, uy, vx, vy) {\n        const dot = ux * vx + uy * vy;\n        const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n        if (ux * vy - uy * vx < 0) ang = -ang;\n        return ang;\n      }\n      function parseRectNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n        const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n        const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n        const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n        const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n        const bci = 1 - 0.551915024494;\n        const path = new ShapePath();\n        path.moveTo(x + rx, y);\n        path.lineTo(x + w - rx, y);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n        }\n        path.lineTo(x + w, y + h - ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n        }\n        path.lineTo(x + rx, y + h);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n        }\n        path.lineTo(x, y + ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n        }\n        return path;\n      }\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a);\n          const y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        const path = new ShapePath();\n        let index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a);\n          const y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        const path = new ShapePath();\n        let index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseCircleNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n        const subpath = new Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        const path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseEllipseNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n        const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n        const subpath = new Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        const path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseLineNode(node) {\n        const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n        const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n        const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n        const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n        const path = new ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseStyle(node, style) {\n        style = Object.assign({}, style);\n        let stylesheetStyles = {};\n        if (node.hasAttribute(\"class\")) {\n          const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map(i => i.trim());\n          for (let i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n          }\n        }\n        if (node.hasAttribute(\"id\")) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n        }\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === void 0) adjustFunction = function copy(v) {\n            if (v.startsWith(\"url\")) console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n            return v;\n          };\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== \"\") style[jsName] = adjustFunction(node.style[svgName]);\n        }\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n        addStyle(\"fill\", \"fill\");\n        addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n        addStyle(\"fill-rule\", \"fillRule\");\n        addStyle(\"opacity\", \"opacity\", clamp);\n        addStyle(\"stroke\", \"stroke\");\n        addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n        addStyle(\"stroke-width\", \"strokeWidth\", positive);\n        addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n        addStyle(\"stroke-linecap\", \"strokeLineCap\");\n        addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n        addStyle(\"visibility\", \"visibility\");\n        return style;\n      }\n      function getReflection(a, b) {\n        return a - (b - a);\n      }\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== \"string\") {\n          throw new TypeError(\"Invalid input: \" + typeof input);\n        }\n        const RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        };\n        const SEP = 0;\n        const INT = 1;\n        const FLOAT = 2;\n        const EXP = 3;\n        let state = SEP;\n        let seenComma = true;\n        let number = \"\",\n          exponent = \"\";\n        const result = [];\n        function throwSyntaxError(current2, i, partial) {\n          const error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n          error.partial = partial;\n          throw error;\n        }\n        function newNumber() {\n          if (number !== \"\") {\n            if (exponent === \"\") result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n          number = \"\";\n          exponent = \"\";\n        }\n        let current;\n        const length = input.length;\n        for (let i = 0; i < length; i++) {\n          current = input[i];\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          }\n          if (state === SEP) {\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            }\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            }\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n              seenComma = true;\n            }\n          }\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n            if (RE.SIGN.test(current)) {\n              if (exponent === \"\") {\n                exponent += current;\n                continue;\n              }\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          }\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        newNumber();\n        return result;\n      }\n      const units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n      const unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n      function parseFloatWithUnits(string) {\n        let theUnit = \"px\";\n        if (typeof string === \"string\" || string instanceof String) {\n          for (let i = 0, n = units.length; i < n; i++) {\n            const u = units[i];\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n        let scale = void 0;\n        if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n          scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n          if (scale < 0) {\n            scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n          }\n        }\n        return scale * parseFloat(string);\n      }\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n          return null;\n        }\n        const transform = parseNodeTransform(node);\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n      function parseNodeTransform(node) {\n        const transform = new Matrix3();\n        const currentTransform2 = tempTransform0;\n        if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n          const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n          const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n          transform.translate(tx, ty);\n        }\n        if (node.hasAttribute(\"transform\")) {\n          const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n          for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            const transformText = transformsTexts[tIndex].trim();\n            if (transformText === \"\") continue;\n            const openParPos = transformText.indexOf(\"(\");\n            const closeParPos = transformText.length;\n            if (openParPos > 0 && openParPos < closeParPos) {\n              const transformType = transformText.slice(0, openParPos);\n              const array = parseFloats(transformText.slice(openParPos + 1));\n              currentTransform2.identity();\n              switch (transformType) {\n                case \"translate\":\n                  if (array.length >= 1) {\n                    const tx = array[0];\n                    let ty = 0;\n                    if (array.length >= 2) {\n                      ty = array[1];\n                    }\n                    currentTransform2.translate(tx, ty);\n                  }\n                  break;\n                case \"rotate\":\n                  if (array.length >= 1) {\n                    let angle = 0;\n                    let cx = 0;\n                    let cy = 0;\n                    angle = array[0] * Math.PI / 180;\n                    if (array.length >= 3) {\n                      cx = array[1];\n                      cy = array[2];\n                    }\n                    tempTransform1.makeTranslation(-cx, -cy);\n                    tempTransform2.makeRotation(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.makeTranslation(cx, cy);\n                    currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n                  break;\n                case \"scale\":\n                  if (array.length >= 1) {\n                    const scaleX = array[0];\n                    let scaleY = scaleX;\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n                    currentTransform2.scale(scaleX, scaleY);\n                  }\n                  break;\n                case \"skewX\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"skewY\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"matrix\":\n                  if (array.length === 6) {\n                    currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n                  break;\n              }\n            }\n            transform.premultiply(currentTransform2);\n          }\n        }\n        return transform;\n      }\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n        function transfEllipseGeneric(curve) {\n          const a = curve.xRadius;\n          const b = curve.yRadius;\n          const cosTheta = Math.cos(curve.aRotation);\n          const sinTheta = Math.sin(curve.aRotation);\n          const v1 = new Vector3(a * cosTheta, a * sinTheta, 0);\n          const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0);\n          const f1 = v1.applyMatrix3(m);\n          const f2 = v2.applyMatrix3(m);\n          const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);\n          const mFInv = tempTransform1.copy(mF).invert();\n          const mFInvT = tempTransform2.copy(mFInv).transpose();\n          const mQ = mFInvT.multiply(mFInv);\n          const mQe = mQ.elements;\n          const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);\n          const rt1sqrt = Math.sqrt(ed.rt1);\n          const rt2sqrt = Math.sqrt(ed.rt2);\n          curve.xRadius = 1 / rt1sqrt;\n          curve.yRadius = 1 / rt2sqrt;\n          curve.aRotation = Math.atan2(ed.sn, ed.cs);\n          const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;\n          if (!isFullEllipse) {\n            const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);\n            const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);\n            const mDRF = mDsqrt.multiply(mRT).multiply(mF);\n            const transformAngle = phi => {\n              const {\n                x: cosR,\n                y: sinR\n              } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);\n              return Math.atan2(sinR, cosR);\n            };\n            curve.aStartAngle = transformAngle(curve.aStartAngle);\n            curve.aEndAngle = transformAngle(curve.aEndAngle);\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise;\n            }\n          }\n        }\n        function transfEllipseNoSkew(curve) {\n          const sx = getTransformScaleX(m);\n          const sy = getTransformScaleY(m);\n          curve.xRadius *= sx;\n          curve.yRadius *= sy;\n          const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);\n          curve.aRotation += theta;\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1;\n            curve.aEndAngle *= -1;\n            curve.aClockwise = !curve.aClockwise;\n          }\n        }\n        const subPaths = path.subPaths;\n        for (let i = 0, n = subPaths.length; i < n; i++) {\n          const subPath = subPaths[i];\n          const curves = subPath.curves;\n          for (let j = 0; j < curves.length; j++) {\n            const curve = curves[j];\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve);\n              } else {\n                transfEllipseNoSkew(curve);\n              }\n            }\n          }\n        }\n      }\n      function isTransformFlipped(m) {\n        const te = m.elements;\n        return te[0] * te[4] - te[1] * te[3] < 0;\n      }\n      function isTransformSkewed(m) {\n        const te = m.elements;\n        const basisDot = te[0] * te[3] + te[1] * te[4];\n        if (basisDot === 0) return false;\n        const sx = getTransformScaleX(m);\n        const sy = getTransformScaleY(m);\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;\n      }\n      function getTransformScaleX(m) {\n        const te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n      function getTransformScaleY(m) {\n        const te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      }\n      function eigenDecomposition(A, B, C) {\n        let rt1, rt2, cs, sn, t;\n        const sm = A + C;\n        const df = A - C;\n        const rt = Math.sqrt(df * df + 4 * B * B);\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt);\n          t = 1 / rt1;\n          rt2 = A * t * C - B * t * B;\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt);\n        } else {\n          rt1 = 0.5 * rt;\n          rt2 = -0.5 * rt;\n        }\n        if (df > 0) {\n          cs = df + rt;\n        } else {\n          cs = df - rt;\n        }\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = -2 * B / cs;\n          sn = 1 / Math.sqrt(1 + t * t);\n          cs = t * sn;\n        } else if (Math.abs(B) === 0) {\n          cs = 1;\n          sn = 0;\n        } else {\n          t = -0.5 * cs / B;\n          cs = 1 / Math.sqrt(1 + t * t);\n          sn = t * cs;\n        }\n        if (df > 0) {\n          t = cs;\n          cs = -sn;\n          sn = t;\n        }\n        return {\n          rt1,\n          rt2,\n          cs,\n          sn\n        };\n      }\n      const paths = [];\n      const stylesheets = {};\n      const transformStack = [];\n      const tempTransform0 = new Matrix3();\n      const tempTransform1 = new Matrix3();\n      const tempTransform2 = new Matrix3();\n      const tempTransform3 = new Matrix3();\n      const tempV2 = new Vector2();\n      const tempV3 = new Vector3();\n      const currentTransform = new Matrix3();\n      const xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n      parseNode(xml.documentElement, {\n        fill: \"#000\",\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: \"miter\",\n        strokeLineCap: \"butt\",\n        strokeMiterLimit: 4\n      });\n      const data = {\n        paths,\n        xml: xml.documentElement\n      };\n      return data;\n    }\n    static createShapes(shapePath) {\n      const BIGNUMBER = 999999999;\n      const IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      const classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        const x1 = a0.x;\n        const x2 = a1.x;\n        const x3 = b0.x;\n        const x4 = b1.x;\n        const y1 = a0.y;\n        const y2 = a1.y;\n        const y3 = b0.y;\n        const y4 = b1.y;\n        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        const t1 = nom1 / denom;\n        const t2 = nom2 / denom;\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1;\n              return {\n                x: point.x,\n                y: point.y,\n                t: classifyResult.t\n              };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return {\n                x,\n                y,\n                t: classifyResult.t\n              };\n            }\n          }\n          return null;\n        } else {\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1;\n              return {\n                x: point.x,\n                y: point.y,\n                t: classifyResult.t\n              };\n            }\n          }\n          const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n          const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n          return {\n            x,\n            y,\n            t: t1\n          };\n        }\n      }\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        const ax = edgeEnd.x - edgeStart.x;\n        const ay = edgeEnd.y - edgeStart.y;\n        const bx = p.x - edgeStart.x;\n        const by = p.y - edgeStart.y;\n        const sa = ax * by - bx * ay;\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n        let t;\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n      function getIntersections(path1, path2) {\n        const intersectionsRaw = [];\n        const intersections = [];\n        for (let index = 1; index < path1.length; index++) {\n          const path1EdgeStart = path1[index - 1];\n          const path1EdgeEnd = path1[index];\n          for (let index2 = 1; index2 < path2.length; index2++) {\n            const path2EdgeStart = path2[index2 - 1];\n            const path2EdgeEnd = path2[index2];\n            const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n            if (intersection !== null && intersectionsRaw.find(i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === void 0) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new Vector2(intersection.x, intersection.y));\n            }\n          }\n        }\n        return intersections;\n      }\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        const center = new Vector2();\n        boundingBox.getCenter(center);\n        const allIntersections = [];\n        paths.forEach(path => {\n          if (path.boundingBox.containsPoint(center)) {\n            const intersections = getIntersections(scanline, path.points);\n            intersections.forEach(p => {\n              allIntersections.push({\n                identifier: path.identifier,\n                isCW: path.isCW,\n                point: p\n              });\n            });\n          }\n        });\n        allIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n      function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n        if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n          _fillRule = \"nonzero\";\n        }\n        const centerBoundingBox = new Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n        const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x;\n        });\n        const baseIntersections = [];\n        const otherIntersections = [];\n        scanlineIntersections.forEach(i2 => {\n          if (i2.identifier === simplePath.identifier) {\n            baseIntersections.push(i2);\n          } else {\n            otherIntersections.push(i2);\n          }\n        });\n        const firstXOfPath = baseIntersections[0].point.x;\n        const stack = [];\n        let i = 0;\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n          i++;\n        }\n        stack.push(simplePath.identifier);\n        if (_fillRule === \"evenodd\") {\n          const isHole = stack.length % 2 === 0 ? true : false;\n          const isHoleFor = stack[stack.length - 2];\n          return {\n            identifier: simplePath.identifier,\n            isHole,\n            for: isHoleFor\n          };\n        } else if (_fillRule === \"nonzero\") {\n          let isHole = true;\n          let isHoleFor = null;\n          let lastCWValue = null;\n          for (let i2 = 0; i2 < stack.length; i2++) {\n            const identifier = stack[i2];\n            if (isHole) {\n              lastCWValue = allPaths[identifier].isCW;\n              isHole = false;\n              isHoleFor = identifier;\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW;\n              isHole = true;\n            }\n          }\n          return {\n            identifier: simplePath.identifier,\n            isHole,\n            for: isHoleFor\n          };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      }\n      let scanlineMinX = BIGNUMBER;\n      let scanlineMaxX = -BIGNUMBER;\n      let simplePaths = shapePath.subPaths.map(p => {\n        const points = p.getPoints();\n        let maxY = -BIGNUMBER;\n        let minY = BIGNUMBER;\n        let maxX = -BIGNUMBER;\n        let minX = BIGNUMBER;\n        for (let i = 0; i < points.length; i++) {\n          const p2 = points[i];\n          if (p2.y > maxY) {\n            maxY = p2.y;\n          }\n          if (p2.y < minY) {\n            minY = p2.y;\n          }\n          if (p2.x > maxX) {\n            maxX = p2.x;\n          }\n          if (p2.x < minX) {\n            minX = p2.x;\n          }\n        }\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n        return {\n          curves: p.curves,\n          points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter(sp => sp.points.length > 1);\n      for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier;\n      }\n      const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0));\n      const shapesToReturn = [];\n      simplePaths.forEach(p => {\n        const amIAHole = isAHole[p.identifier];\n        if (!amIAHole.isHole) {\n          const shape = new Shape();\n          shape.curves = p.curves;\n          const holes = isAHole.filter(h => h.isHole && h.for === p.identifier);\n          holes.forEach(h => {\n            const hole = simplePaths[h.identifier];\n            const path = new Path();\n            path.curves = hole.curves;\n            shape.holes.push(path);\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      width = width !== void 0 ? width : 1;\n      color = color !== void 0 ? color : \"#000\";\n      lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n      lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n      miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      if (SVGLoader2.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      const tempV2_1 = new Vector2();\n      const tempV2_2 = new Vector2();\n      const tempV2_3 = new Vector2();\n      const tempV2_4 = new Vector2();\n      const tempV2_5 = new Vector2();\n      const tempV2_6 = new Vector2();\n      const tempV2_7 = new Vector2();\n      const lastPointL = new Vector2();\n      const lastPointR = new Vector2();\n      const point0L = new Vector2();\n      const point0R = new Vector2();\n      const currentPointL = new Vector2();\n      const currentPointR = new Vector2();\n      const nextPointL = new Vector2();\n      const nextPointR = new Vector2();\n      const innerPoint = new Vector2();\n      const outerPoint = new Vector2();\n      arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n      minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n      vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n      points = removeDuplicatedPoints(points);\n      const numPoints = points.length;\n      if (numPoints < 2) return 0;\n      const isClosed = points[0].equals(points[numPoints - 1]);\n      let currentPoint;\n      let previousPoint = points[0];\n      let nextPoint;\n      const strokeWidth2 = style.strokeWidth / 2;\n      const deltaU = 1 / (numPoints - 1);\n      let u0 = 0,\n        u1;\n      let innerSideModified;\n      let joinIsOnLeftSide;\n      let isMiter;\n      let initialJoinIsOnLeftSide = false;\n      let numVertices = 0;\n      let currentCoordinate = vertexOffset * 3;\n      let currentCoordinateUV = vertexOffset * 2;\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n      for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint];\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            nextPoint = points[1];\n          } else nextPoint = void 0;\n        } else {\n          nextPoint = points[iPoint + 1];\n        }\n        const normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n        if (nextPoint !== void 0) {\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          const dot = Math.abs(normal1.dot(tempV2_3));\n          if (dot > Number.EPSILON) {\n            const miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            const miterLength2 = tempV2_5.length();\n            const segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            const segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext);\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              makeSegmentTriangles();\n            }\n            switch (style.strokeLineJoin) {\n              case \"bevel\":\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n              case \"round\":\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n                break;\n              case \"miter\":\n              case \"miter-clip\":\n              default:\n                const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n                if (miterFraction < 1) {\n                  if (style.strokeLineJoin !== \"miter-clip\") {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                  isMiter = true;\n                }\n                break;\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n        if (!isClosed && iPoint === numPoints - 1) {\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        }\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n      if (!isClosed) {\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        let lastOuter = outerPoint;\n        let lastInner = innerPoint;\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n      return numVertices;\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n          currentCoordinate += 3;\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n        numVertices += 3;\n      }\n      function makeCircularSector(center, p1, p2, u, v) {\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        let angle = Math.PI;\n        const dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n        for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 0);\n        addVertex(currentPointR, u1, 1);\n      }\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u, 1);\n            addVertex(innerPoint, u, 0);\n            addVertex(nextPointR, u, 1);\n          }\n        } else {\n          if (joinIsOnLeftSide2) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n        switch (style.strokeLineCap) {\n          case \"round\":\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n            break;\n          case \"square\":\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              const vl = vertices.length;\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n            break;\n        }\n      }\n      function removeDuplicatedPoints(points2) {\n        let dupPoints = false;\n        for (let i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n        if (!dupPoints) return points2;\n        const newPoints = [];\n        newPoints.push(points2[0]);\n        for (let i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {\n            newPoints.push(points2[i]);\n          }\n        }\n        newPoints.push(points2[points2.length - 1]);\n        return newPoints;\n      }\n    }\n  }\n  return SVGLoader2;\n})();\nexport { SVGLoader };\n//# sourceMappingURL=SVGLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}