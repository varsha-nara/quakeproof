{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector2, Color, WebGLRenderTarget, HalfFloatType, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityHighPassShader } from \"../shaders/LuminosityHighPassShader.js\";\nconst UnrealBloomPass = /* @__PURE__ */(() => {\n  const _UnrealBloomPass = class extends Pass {\n    constructor(resolution, strength, radius, threshold) {\n      super();\n      this.strength = strength !== void 0 ? strength : 1;\n      this.radius = radius;\n      this.threshold = threshold;\n      this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n      this.clearColor = new Color(0, 0, 0);\n      this.renderTargetsHorizontal = [];\n      this.renderTargetsVertical = [];\n      this.nMips = 5;\n      let resx = Math.round(this.resolution.x / 2);\n      let resy = Math.round(this.resolution.y / 2);\n      this.renderTargetBright = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      this.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n      this.renderTargetBright.texture.generateMipmaps = false;\n      for (let i = 0; i < this.nMips; i++) {\n        const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, {\n          type: HalfFloatType\n        });\n        renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n        renderTargetHorizonal.texture.generateMipmaps = false;\n        this.renderTargetsHorizontal.push(renderTargetHorizonal);\n        const renderTargetVertical = new WebGLRenderTarget(resx, resy, {\n          type: HalfFloatType\n        });\n        renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n        renderTargetVertical.texture.generateMipmaps = false;\n        this.renderTargetsVertical.push(renderTargetVertical);\n        resx = Math.round(resx / 2);\n        resy = Math.round(resy / 2);\n      }\n      const highPassShader = LuminosityHighPassShader;\n      this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n      this.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n      this.highPassUniforms[\"smoothWidth\"].value = 0.01;\n      this.materialHighPassFilter = new ShaderMaterial({\n        uniforms: this.highPassUniforms,\n        vertexShader: highPassShader.vertexShader,\n        fragmentShader: highPassShader.fragmentShader,\n        defines: {}\n      });\n      this.separableBlurMaterials = [];\n      const kernelSizeArray = [3, 5, 7, 9, 11];\n      resx = Math.round(this.resolution.x / 2);\n      resy = Math.round(this.resolution.y / 2);\n      for (let i = 0; i < this.nMips; i++) {\n        this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n        this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n        resx = Math.round(resx / 2);\n        resy = Math.round(resy / 2);\n      }\n      this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n      this.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n      this.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n      this.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n      this.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n      this.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n      this.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n      this.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n      this.compositeMaterial.needsUpdate = true;\n      const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];\n      this.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n      this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n      this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n      const copyShader = CopyShader;\n      this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n      this.copyUniforms[\"opacity\"].value = 1;\n      this.materialCopy = new ShaderMaterial({\n        uniforms: this.copyUniforms,\n        vertexShader: copyShader.vertexShader,\n        fragmentShader: copyShader.fragmentShader,\n        blending: AdditiveBlending,\n        depthTest: false,\n        depthWrite: false,\n        transparent: true\n      });\n      this.enabled = true;\n      this.needsSwap = false;\n      this._oldClearColor = new Color();\n      this.oldClearAlpha = 1;\n      this.basic = new MeshBasicMaterial();\n      this.fsQuad = new FullScreenQuad(null);\n    }\n    dispose() {\n      for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n        this.renderTargetsHorizontal[i].dispose();\n      }\n      for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n        this.renderTargetsVertical[i].dispose();\n      }\n      this.renderTargetBright.dispose();\n      for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n        this.separableBlurMaterials[i].dispose();\n      }\n      this.compositeMaterial.dispose();\n      this.materialCopy.dispose();\n      this.basic.dispose();\n      this.fsQuad.dispose();\n    }\n    setSize(width, height) {\n      let resx = Math.round(width / 2);\n      let resy = Math.round(height / 2);\n      this.renderTargetBright.setSize(resx, resy);\n      for (let i = 0; i < this.nMips; i++) {\n        this.renderTargetsHorizontal[i].setSize(resx, resy);\n        this.renderTargetsVertical[i].setSize(resx, resy);\n        this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n        resx = Math.round(resx / 2);\n        resy = Math.round(resy / 2);\n      }\n    }\n    render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      const oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.setClearColor(this.clearColor, 0);\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.basic;\n        this.basic.map = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n      this.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n      this.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n      this.fsQuad.material = this.materialHighPassFilter;\n      renderer.setRenderTarget(this.renderTargetBright);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      let inputRenderTarget = this.renderTargetBright;\n      for (let i = 0; i < this.nMips; i++) {\n        this.fsQuad.material = this.separableBlurMaterials[i];\n        this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n        this.separableBlurMaterials[i].uniforms[\"direction\"].value = _UnrealBloomPass.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n        this.separableBlurMaterials[i].uniforms[\"direction\"].value = _UnrealBloomPass.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetsVertical[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        inputRenderTarget = this.renderTargetsVertical[i];\n      }\n      this.fsQuad.material = this.compositeMaterial;\n      this.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n      this.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n      this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      } else {\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n      }\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n    getSeperableBlurMaterial(kernelRadius) {\n      return new ShaderMaterial({\n        defines: {\n          KERNEL_RADIUS: kernelRadius,\n          SIGMA: kernelRadius\n        },\n        uniforms: {\n          colorTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          direction: {\n            value: new Vector2(0.5, 0.5)\n          }\n        },\n        vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n        fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n      });\n    }\n    getCompositeMaterial(nMips) {\n      return new ShaderMaterial({\n        defines: {\n          NUM_MIPS: nMips\n        },\n        uniforms: {\n          blurTexture1: {\n            value: null\n          },\n          blurTexture2: {\n            value: null\n          },\n          blurTexture3: {\n            value: null\n          },\n          blurTexture4: {\n            value: null\n          },\n          blurTexture5: {\n            value: null\n          },\n          bloomStrength: {\n            value: 1\n          },\n          bloomFactors: {\n            value: null\n          },\n          bloomTintColors: {\n            value: null\n          },\n          bloomRadius: {\n            value: 0\n          }\n        },\n        vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n        fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n      });\n    }\n  };\n  let UnrealBloomPass2 = _UnrealBloomPass;\n  __publicField(UnrealBloomPass2, \"BlurDirectionX\", new Vector2(1, 0));\n  __publicField(UnrealBloomPass2, \"BlurDirectionY\", new Vector2(0, 1));\n  return UnrealBloomPass2;\n})();\nexport { UnrealBloomPass };\n//# sourceMappingURL=UnrealBloomPass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}