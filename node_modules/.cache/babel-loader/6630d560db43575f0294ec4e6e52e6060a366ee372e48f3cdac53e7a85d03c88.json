{"ast":null,"code":"/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-Bj1xl_EK.js';\nimport { c as createDecodeFunction, L as LoaderBaseShared, e as extractGainmapFromJPEG, X as XMPMetadataNotFoundError, G as GainMapNotFoundError } from './Loader-DLI-_JDP.js';\nexport { M as MPFExtractor, a as extractXMP } from './Loader-DLI-_JDP.js';\nimport { ShaderMaterial, NoBlending, Vector3, WebGLRenderer, FileLoader } from 'three';\nconst vertexShader = /* glsl */`\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */`\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n  _maxDisplayBoost;\n  _hdrCapacityMin;\n  _hdrCapacityMax;\n  /**\n   *\n   * @param params\n   */\n  constructor({\n    gamma,\n    offsetHdr,\n    offsetSdr,\n    gainMapMin,\n    gainMapMax,\n    maxDisplayBoost,\n    hdrCapacityMin,\n    hdrCapacityMax,\n    sdr,\n    gainMap\n  }) {\n    super({\n      name: 'GainMapDecoderMaterial',\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        sdr: {\n          value: sdr\n        },\n        gainMap: {\n          value: gainMap\n        },\n        gamma: {\n          value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n        },\n        offsetHdr: {\n          value: new Vector3().fromArray(offsetHdr)\n        },\n        offsetSdr: {\n          value: new Vector3().fromArray(offsetSdr)\n        },\n        gainMapMin: {\n          value: new Vector3().fromArray(gainMapMin)\n        },\n        gainMapMax: {\n          value: new Vector3().fromArray(gainMapMax)\n        },\n        weightFactor: {\n          value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n        }\n      },\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    this._maxDisplayBoost = maxDisplayBoost;\n    this._hdrCapacityMin = hdrCapacityMin;\n    this._hdrCapacityMax = hdrCapacityMax;\n    this.needsUpdate = true;\n    this.uniformsNeedUpdate = true;\n  }\n  get sdr() {\n    return this.uniforms.sdr.value;\n  }\n  set sdr(value) {\n    this.uniforms.sdr.value = value;\n  }\n  get gainMap() {\n    return this.uniforms.gainMap.value;\n  }\n  set gainMap(value) {\n    this.uniforms.gainMap.value = value;\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetHdr}\n   */\n  get offsetHdr() {\n    return this.uniforms.offsetHdr.value.toArray();\n  }\n  set offsetHdr(value) {\n    this.uniforms.offsetHdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetSdr}\n   */\n  get offsetSdr() {\n    return this.uniforms.offsetSdr.value.toArray();\n  }\n  set offsetSdr(value) {\n    this.uniforms.offsetSdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMin}\n   */\n  get gainMapMin() {\n    return this.uniforms.gainMapMin.value.toArray();\n  }\n  set gainMapMin(value) {\n    this.uniforms.gainMapMin.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMax}\n   */\n  get gainMapMax() {\n    return this.uniforms.gainMapMax.value.toArray();\n  }\n  set gainMapMax(value) {\n    this.uniforms.gainMapMax.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gamma}\n   */\n  get gamma() {\n    const g = this.uniforms.gamma.value;\n    return [1 / g.x, 1 / g.y, 1 / g.z];\n  }\n  set gamma(value) {\n    const g = this.uniforms.gamma.value;\n    g.x = 1.0 / value[0];\n    g.y = 1.0 / value[1];\n    g.z = 1.0 / value[2];\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMin() {\n    return this._hdrCapacityMin;\n  }\n  set hdrCapacityMin(value) {\n    this._hdrCapacityMin = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMax() {\n    return this._hdrCapacityMax;\n  }\n  set hdrCapacityMax(value) {\n    this._hdrCapacityMax = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n   * @remarks Non Logarithmic space\n   */\n  get maxDisplayBoost() {\n    return this._maxDisplayBoost;\n  }\n  set maxDisplayBoost(value) {\n    this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n    this.calculateWeight();\n  }\n  calculateWeight() {\n    const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n  }\n}\nconst decodeImpl = createDecodeFunction({\n  renderer: WebGLRenderer,\n  createMaterial: params => new GainMapDecoderMaterial(params),\n  createQuadRenderer: params => new QuadRenderer(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = params => {\n  // Ensure renderer is defined for the base function\n  if (!params.renderer) {\n    throw new Error('Renderer is required for decode function');\n  }\n  const quadRenderer = decodeImpl({\n    ...params,\n    renderer: params.renderer\n  });\n  try {\n    quadRenderer.render();\n  } catch (e) {\n    quadRenderer.disposeOnDemandRenderer();\n    throw e;\n  }\n  return quadRenderer;\n};\n\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */\nclass LoaderBaseWebGL extends LoaderBaseShared {\n  constructor(renderer, manager) {\n    super({\n      renderer,\n      createMaterial: params => new GainMapDecoderMaterial(params),\n      createQuadRenderer: params => new QuadRenderer(params)\n    }, manager);\n  }\n  /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n  async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n    const {\n      sdrImage,\n      gainMapImage,\n      needsFlip\n    } = await this.processImages(sdrBuffer, gainMapBuffer, 'flipY');\n    const {\n      gainMap,\n      sdr\n    } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n    this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n    quadRenderer.render();\n  }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBaseWebGL {\n  /**\n   * Loads a gainmap using separate data\n   * * sdr image\n   * * gain map image\n   * * metadata json\n   *\n   * useful for webp gain maps\n   *\n   * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a `ProgressEvent`\n   * @param onError Error callback\n   * @returns\n   */\n  load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n    const quadRenderer = this.prepareQuadRenderer();\n    let sdr;\n    let gainMap;\n    let metadata;\n    const loadCheck = async () => {\n      if (sdr && gainMap && metadata) {\n        // solves #16\n        try {\n          await this.render(quadRenderer, metadata, sdr, gainMap);\n        } catch (error) {\n          this.manager.itemError(sdrUrl);\n          this.manager.itemError(gainMapUrl);\n          this.manager.itemError(metadataUrl);\n          if (typeof onError === 'function') onError(error);\n          quadRenderer.disposeOnDemandRenderer();\n          return;\n        }\n        if (typeof onLoad === 'function') onLoad(quadRenderer);\n        this.manager.itemEnd(sdrUrl);\n        this.manager.itemEnd(gainMapUrl);\n        this.manager.itemEnd(metadataUrl);\n        quadRenderer.disposeOnDemandRenderer();\n      }\n    };\n    let sdrLengthComputable = true;\n    let sdrTotal = 0;\n    let sdrLoaded = 0;\n    let gainMapLengthComputable = true;\n    let gainMapTotal = 0;\n    let gainMapLoaded = 0;\n    let metadataLengthComputable = true;\n    let metadataTotal = 0;\n    let metadataLoaded = 0;\n    const progressHandler = () => {\n      if (typeof onProgress === 'function') {\n        const total = sdrTotal + gainMapTotal + metadataTotal;\n        const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n        const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n        onProgress(new ProgressEvent('progress', {\n          lengthComputable,\n          loaded,\n          total\n        }));\n      }\n    };\n    this.manager.itemStart(sdrUrl);\n    this.manager.itemStart(gainMapUrl);\n    this.manager.itemStart(metadataUrl);\n    const sdrLoader = new FileLoader(this._internalLoadingManager);\n    sdrLoader.setResponseType('arraybuffer');\n    sdrLoader.setRequestHeader(this.requestHeader);\n    sdrLoader.setPath(this.path);\n    sdrLoader.setWithCredentials(this.withCredentials);\n    sdrLoader.load(sdrUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid sdr buffer');\n      sdr = buffer;\n      await loadCheck();\n    }, e => {\n      sdrLengthComputable = e.lengthComputable;\n      sdrLoaded = e.loaded;\n      sdrTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(sdrUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const gainMapLoader = new FileLoader(this._internalLoadingManager);\n    gainMapLoader.setResponseType('arraybuffer');\n    gainMapLoader.setRequestHeader(this.requestHeader);\n    gainMapLoader.setPath(this.path);\n    gainMapLoader.setWithCredentials(this.withCredentials);\n    gainMapLoader.load(gainMapUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid gainmap buffer');\n      gainMap = buffer;\n      await loadCheck();\n    }, e => {\n      gainMapLengthComputable = e.lengthComputable;\n      gainMapLoaded = e.loaded;\n      gainMapTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(gainMapUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const metadataLoader = new FileLoader(this._internalLoadingManager);\n    // metadataLoader.setResponseType('json')\n    metadataLoader.setRequestHeader(this.requestHeader);\n    metadataLoader.setPath(this.path);\n    metadataLoader.setWithCredentials(this.withCredentials);\n    metadataLoader.load(metadataUrl, async json => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof json !== 'string') throw new Error('Invalid metadata string');\n      // TODO: implement check on JSON file and remove this eslint disable\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      metadata = JSON.parse(json);\n      await loadCheck();\n    }, e => {\n      metadataLengthComputable = e.lengthComputable;\n      metadataLoaded = e.loaded;\n      metadataTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(metadataUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBaseWebGL {\n  /**\n   * Loads a JPEG containing gain map metadata\n   * Renders a normal SDR image if gainmap data is not found\n   *\n   * @param url Path to a JPEG file containing embedded gain map metadata\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a `ProgressEvent`\n   * @param onError Error callback\n   * @returns\n   */\n  load(url, onLoad, onProgress, onError) {\n    const quadRenderer = this.prepareQuadRenderer();\n    const loader = new FileLoader(this._internalLoadingManager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    this.manager.itemStart(url);\n    loader.load(url, async jpeg => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof jpeg === 'string') throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n      const jpegBuffer = new Uint8Array(jpeg);\n      let sdrJPEG;\n      let gainMapJPEG;\n      let metadata;\n      try {\n        const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n        // gain map is successfully reconstructed\n        sdrJPEG = extractionResult.sdr;\n        gainMapJPEG = extractionResult.gainMap;\n        metadata = extractionResult.metadata;\n      } catch (e) {\n        // render the SDR version if this is not a gainmap\n        if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n          console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n          metadata = {\n            gainMapMin: [0, 0, 0],\n            gainMapMax: [1, 1, 1],\n            gamma: [1, 1, 1],\n            hdrCapacityMin: 0,\n            hdrCapacityMax: 1,\n            offsetHdr: [0, 0, 0],\n            offsetSdr: [0, 0, 0]\n          };\n          sdrJPEG = jpegBuffer;\n        } else {\n          throw e;\n        }\n      }\n      // solves #16\n      try {\n        await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n      } catch (error) {\n        this.manager.itemError(url);\n        if (typeof onError === 'function') onError(error);\n        quadRenderer.disposeOnDemandRenderer();\n        return;\n      }\n      if (typeof onLoad === 'function') onLoad(quadRenderer);\n      this.manager.itemEnd(url);\n      quadRenderer.disposeOnDemandRenderer();\n    }, onProgress, error => {\n      this.manager.itemError(url);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\nexport { GainMapDecoderMaterial, GainMapLoader, GainMapNotFoundError, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, LoaderBaseShared, QuadRenderer, XMPMetadataNotFoundError, createDecodeFunction, decode, extractGainmapFromJPEG };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}