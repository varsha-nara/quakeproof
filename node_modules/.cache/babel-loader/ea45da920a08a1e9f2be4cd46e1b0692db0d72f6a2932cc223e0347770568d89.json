{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, UnsignedByteType, CompressedTexture, LinearFilter, LinearMipmapLinearFilter, FloatType, HalfFloatType, DataTexture, RGFormat, RedFormat, RGBA_ASTC_6x6_Format } from \"three\";\nimport { WorkerPool } from \"../utils/WorkerPool.js\";\nimport { KHR_DF_FLAG_ALPHA_PREMULTIPLIED, read, VK_FORMAT_UNDEFINED, KHR_SUPERCOMPRESSION_ZSTD, KHR_SUPERCOMPRESSION_NONE, KHR_DF_PRIMARIES_BT709, KHR_DF_TRANSFER_SRGB, KHR_DF_PRIMARIES_DISPLAYP3, KHR_DF_PRIMARIES_UNSPECIFIED, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK } from \"../libs/ktx-parse.js\";\nimport { ZSTDDecoder } from \"../libs/zstddec.js\";\nimport { CompressedCubeTexture } from \"../_polyfill/CompressedCubeTexture.js\";\nimport { CompressedArrayTexture } from \"../_polyfill/CompressedArrayTexture.js\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nconst LinearEncoding = 3e3;\nconst sRGBEncoding = 3001;\nconst NoColorSpace = \"\";\nconst DisplayP3ColorSpace = \"display-p3\";\nconst LinearDisplayP3ColorSpace = \"display-p3-linear\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst SRGBColorSpace = \"srgb\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nlet _activeLoaders = 0;\nlet _zstd;\nconst KTX2Loader = /* @__PURE__ */(() => {\n  const _KTX2Loader = class extends Loader {\n    constructor(manager) {\n      super(manager);\n      this.transcoderPath = \"\";\n      this.transcoderBinary = null;\n      this.transcoderPending = null;\n      this.workerPool = new WorkerPool();\n      this.workerSourceURL = \"\";\n      this.workerConfig = null;\n      if (typeof MSC_TRANSCODER !== \"undefined\") {\n        console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\". \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n      }\n    }\n    setTranscoderPath(path) {\n      this.transcoderPath = path;\n      return this;\n    }\n    setWorkerLimit(num) {\n      this.workerPool.setWorkerLimit(num);\n      return this;\n    }\n    detectSupport(renderer) {\n      this.workerConfig = {\n        astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n        etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n        etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n        dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n        bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n        pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n      };\n      if (renderer.capabilities.isWebGL2) {\n        this.workerConfig.etc1Supported = false;\n      }\n      return this;\n    }\n    init() {\n      if (!this.transcoderPending) {\n        const jsLoader = new FileLoader(this.manager);\n        jsLoader.setPath(this.transcoderPath);\n        jsLoader.setWithCredentials(this.withCredentials);\n        const jsContent = jsLoader.loadAsync(\"basis_transcoder.js\");\n        const binaryLoader = new FileLoader(this.manager);\n        binaryLoader.setPath(this.transcoderPath);\n        binaryLoader.setResponseType(\"arraybuffer\");\n        binaryLoader.setWithCredentials(this.withCredentials);\n        const binaryContent = binaryLoader.loadAsync(\"basis_transcoder.wasm\");\n        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n          const fn = _KTX2Loader.BasisWorker.toString();\n          const body = [\"/* constants */\", \"let _EngineFormat = \" + JSON.stringify(_KTX2Loader.EngineFormat), \"let _TranscoderFormat = \" + JSON.stringify(_KTX2Loader.TranscoderFormat), \"let _BasisFormat = \" + JSON.stringify(_KTX2Loader.BasisFormat), \"/* basis_transcoder.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n          this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n          this.transcoderBinary = binaryContent2;\n          this.workerPool.setWorkerCreator(() => {\n            const worker = new Worker(this.workerSourceURL);\n            const transcoderBinary = this.transcoderBinary.slice(0);\n            worker.postMessage({\n              type: \"init\",\n              config: this.workerConfig,\n              transcoderBinary\n            }, [transcoderBinary]);\n            return worker;\n          });\n        });\n        if (_activeLoaders > 0) {\n          console.warn(\"THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.\");\n        }\n        _activeLoaders++;\n      }\n      return this.transcoderPending;\n    }\n    load(url, onLoad, onProgress, onError) {\n      if (this.workerConfig === null) {\n        throw new Error(\"THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.\");\n      }\n      const loader = new FileLoader(this.manager);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, buffer => {\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer);\n          return cachedTask.promise.then(onLoad).catch(onError);\n        }\n        this._createTexture(buffer).then(texture => onLoad ? onLoad(texture) : null).catch(onError);\n      }, onProgress, onError);\n    }\n    _createTextureFrom(transcodeResult, container) {\n      const {\n        faces,\n        width,\n        height,\n        format,\n        type,\n        error,\n        dfdFlags\n      } = transcodeResult;\n      if (type === \"error\") return Promise.reject(error);\n      let texture;\n      if (container.faceCount === 6) {\n        texture = new CompressedCubeTexture(faces, format, UnsignedByteType);\n      } else {\n        const mipmaps = faces[0].mipmaps;\n        texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      }\n      texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      const colorSpace = parseColorSpace(container);\n      if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);\n      return texture;\n    }\n    /**\n     * @param {ArrayBuffer} buffer\n     * @param {object?} config\n     * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n     */\n    async _createTexture(buffer, config = {}) {\n      const container = read(new Uint8Array(buffer));\n      if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n        return createRawTexture(container);\n      }\n      const taskConfig = config;\n      const texturePending = this.init().then(() => {\n        return this.workerPool.postMessage({\n          type: \"transcode\",\n          buffer,\n          taskConfig\n        }, [buffer]);\n      }).then(e => this._createTextureFrom(e.data, container));\n      _taskCache.set(buffer, {\n        promise: texturePending\n      });\n      return texturePending;\n    }\n    dispose() {\n      this.workerPool.dispose();\n      if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);\n      _activeLoaders--;\n      return this;\n    }\n  };\n  let KTX2Loader2 = _KTX2Loader;\n  /* CONSTANTS */\n  __publicField(KTX2Loader2, \"BasisFormat\", {\n    ETC1S: 0,\n    UASTC_4x4: 1\n  });\n  __publicField(KTX2Loader2, \"TranscoderFormat\", {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16\n  });\n  __publicField(KTX2Loader2, \"EngineFormat\", {\n    RGBAFormat,\n    RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format,\n    RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format\n  });\n  /* WEB WORKER */\n  __publicField(KTX2Loader2, \"BasisWorker\", function () {\n    let config;\n    let transcoderPending;\n    let BasisModule;\n    const EngineFormat = _EngineFormat;\n    const TranscoderFormat = _TranscoderFormat;\n    const BasisFormat = _BasisFormat;\n    self.addEventListener(\"message\", function (e) {\n      const message = e.data;\n      switch (message.type) {\n        case \"init\":\n          config = message.config;\n          init(message.transcoderBinary);\n          break;\n        case \"transcode\":\n          transcoderPending.then(() => {\n            try {\n              const {\n                faces,\n                buffers,\n                width,\n                height,\n                hasAlpha,\n                format,\n                dfdFlags\n              } = transcode(message.buffer);\n              self.postMessage({\n                type: \"transcode\",\n                id: message.id,\n                faces,\n                width,\n                height,\n                hasAlpha,\n                format,\n                dfdFlags\n              }, buffers);\n            } catch (error) {\n              console.error(error);\n              self.postMessage({\n                type: \"error\",\n                id: message.id,\n                error: error.message\n              });\n            }\n          });\n          break;\n      }\n    });\n    function init(wasmBinary) {\n      transcoderPending = new Promise(resolve => {\n        BasisModule = {\n          wasmBinary,\n          onRuntimeInitialized: resolve\n        };\n        BASIS(BasisModule);\n      }).then(() => {\n        BasisModule.initializeBasis();\n        if (BasisModule.KTX2File === void 0) {\n          console.warn(\"THREE.KTX2Loader: Please update Basis Universal transcoder.\");\n        }\n      });\n    }\n    function transcode(buffer) {\n      const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\n      function cleanup() {\n        ktx2File.close();\n        ktx2File.delete();\n      }\n      if (!ktx2File.isValid()) {\n        cleanup();\n        throw new Error(\"THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file\");\n      }\n      const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n      const width = ktx2File.getWidth();\n      const height = ktx2File.getHeight();\n      const layerCount = ktx2File.getLayers() || 1;\n      const levelCount = ktx2File.getLevels();\n      const faceCount = ktx2File.getFaces();\n      const hasAlpha = ktx2File.getHasAlpha();\n      const dfdFlags = ktx2File.getDFDFlags();\n      const {\n        transcoderFormat,\n        engineFormat\n      } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n      if (!width || !height || !levelCount) {\n        cleanup();\n        throw new Error(\"THREE.KTX2Loader:\tInvalid texture\");\n      }\n      if (!ktx2File.startTranscoding()) {\n        cleanup();\n        throw new Error(\"THREE.KTX2Loader: .startTranscoding failed\");\n      }\n      const faces = [];\n      const buffers = [];\n      for (let face = 0; face < faceCount; face++) {\n        const mipmaps = [];\n        for (let mip = 0; mip < levelCount; mip++) {\n          const layerMips = [];\n          let mipWidth, mipHeight;\n          for (let layer = 0; layer < layerCount; layer++) {\n            const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);\n            if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {\n              console.warn(\"THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.\");\n            }\n            if (levelCount > 1) {\n              mipWidth = levelInfo.origWidth;\n              mipHeight = levelInfo.origHeight;\n            } else {\n              mipWidth = levelInfo.width;\n              mipHeight = levelInfo.height;\n            }\n            const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));\n            const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);\n            if (!status) {\n              cleanup();\n              throw new Error(\"THREE.KTX2Loader: .transcodeImage failed.\");\n            }\n            layerMips.push(dst);\n          }\n          const mipData = concat(layerMips);\n          mipmaps.push({\n            data: mipData,\n            width: mipWidth,\n            height: mipHeight\n          });\n          buffers.push(mipData.buffer);\n        }\n        faces.push({\n          mipmaps,\n          width,\n          height,\n          format: engineFormat\n        });\n      }\n      cleanup();\n      return {\n        faces,\n        buffers,\n        width,\n        height,\n        hasAlpha,\n        format: engineFormat,\n        dfdFlags\n      };\n    }\n    const FORMAT_OPTIONS = [{\n      if: \"astcSupported\",\n      basisFormat: [BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n      priorityETC1S: Infinity,\n      priorityUASTC: 1,\n      needsPowerOfTwo: false\n    }, {\n      if: \"bptcSupported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n      priorityETC1S: 3,\n      priorityUASTC: 2,\n      needsPowerOfTwo: false\n    }, {\n      if: \"dxtSupported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n      engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n      priorityETC1S: 4,\n      priorityUASTC: 5,\n      needsPowerOfTwo: false\n    }, {\n      if: \"etc2Supported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n      priorityETC1S: 1,\n      priorityUASTC: 3,\n      needsPowerOfTwo: false\n    }, {\n      if: \"etc1Supported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.ETC1],\n      engineFormat: [EngineFormat.RGB_ETC1_Format],\n      priorityETC1S: 2,\n      priorityUASTC: 4,\n      needsPowerOfTwo: false\n    }, {\n      if: \"pvrtcSupported\",\n      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n      priorityETC1S: 5,\n      priorityUASTC: 6,\n      needsPowerOfTwo: true\n    }];\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S;\n    });\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC;\n    });\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat;\n      let engineFormat;\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i];\n        if (!config[opt.if]) continue;\n        if (!opt.basisFormat.includes(basisFormat)) continue;\n        if (hasAlpha && opt.transcoderFormat.length < 2) continue;\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n        return {\n          transcoderFormat,\n          engineFormat\n        };\n      }\n      console.warn(\"THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.\");\n      transcoderFormat = TranscoderFormat.RGBA32;\n      engineFormat = EngineFormat.RGBAFormat;\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true;\n      return (value & value - 1) === 0 && value !== 0;\n    }\n    function concat(arrays) {\n      if (arrays.length === 1) return arrays[0];\n      let totalByteLength = 0;\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i];\n        totalByteLength += array.byteLength;\n      }\n      const result = new Uint8Array(totalByteLength);\n      let byteOffset = 0;\n      for (let i = 0; i < arrays.length; i++) {\n        const array = arrays[i];\n        result.set(array, byteOffset);\n        byteOffset += array.byteLength;\n      }\n      return result;\n    }\n  });\n  return KTX2Loader2;\n})();\nconst UNCOMPRESSED_FORMATS = /* @__PURE__ */new Set([RGBAFormat, RGFormat, RedFormat]);\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format\n};\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType\n};\nasync function createRawTexture(container) {\n  const {\n    vkFormat\n  } = container;\n  if (FORMAT_MAP[vkFormat] === void 0) {\n    throw new Error(\"THREE.KTX2Loader: Unsupported vkFormat.\");\n  }\n  let zstd;\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async resolve => {\n        const zstd2 = new ZSTDDecoder();\n        await zstd2.init();\n        resolve(zstd2);\n      });\n    }\n    zstd = await _zstd;\n  }\n  const mipmaps = [];\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;\n    const level = container.levels[levelIndex];\n    let levelData;\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData;\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);\n    } else {\n      throw new Error(\"THREE.KTX2Loader: Unsupported supercompressionScheme.\");\n    }\n    let data;\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);\n    } else {\n      data = levelData;\n    }\n    mipmaps.push({\n      data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth\n    });\n  }\n  let texture;\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);\n  } else {\n    if (container.pixelDepth > 0) throw new Error(\"THREE.KTX2Loader: Unsupported pixelDepth.\");\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);\n  }\n  texture.mipmaps = mipmaps;\n  texture.type = TYPE_MAP[vkFormat];\n  texture.format = FORMAT_MAP[vkFormat];\n  texture.needsUpdate = true;\n  const colorSpace = parseColorSpace(container);\n  if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n  return Promise.resolve(texture);\n}\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0];\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace;\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`);\n    return NoColorSpace;\n  }\n}\nexport { KTX2Loader };\n//# sourceMappingURL=KTX2Loader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}