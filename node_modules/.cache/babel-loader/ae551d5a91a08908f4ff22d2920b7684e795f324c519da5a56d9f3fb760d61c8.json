{"ast":null,"code":"/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { ClampToEdgeWrapping, LinearFilter, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, RGBAFormat, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, MeshBasicMaterial, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType } from 'three';\nconst getBufferForType = (type, width, height) => {\n  let out;\n  switch (type) {\n    case UnsignedByteType:\n      out = new Uint8ClampedArray(width * height * 4);\n      break;\n    case HalfFloatType:\n      out = new Uint16Array(width * height * 4);\n      break;\n    case UnsignedIntType:\n      out = new Uint32Array(width * height * 4);\n      break;\n    case ByteType:\n      out = new Int8Array(width * height * 4);\n      break;\n    case ShortType:\n      out = new Int16Array(width * height * 4);\n      break;\n    case IntType:\n      out = new Int32Array(width * height * 4);\n      break;\n    case FloatType:\n      out = new Float32Array(width * height * 4);\n      break;\n    default:\n      throw new Error('Unsupported data type');\n  }\n  return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n  if (_canReadPixelsResult !== undefined) return _canReadPixelsResult;\n  const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n  renderer.setRenderTarget(testRT);\n  const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({\n    color: 0xffffff\n  }));\n  renderer.render(mesh, camera);\n  renderer.setRenderTarget(null);\n  const out = getBufferForType(type, testRT.width, testRT.height);\n  renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n  testRT.dispose();\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  _canReadPixelsResult = out[0] !== 0;\n  return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n  _renderer;\n  _rendererIsDisposable = false;\n  _material;\n  _scene;\n  _camera;\n  _quad;\n  _renderTarget;\n  _width;\n  _height;\n  _type;\n  _colorSpace;\n  _supportsReadPixels = true;\n  /**\n   * Constructs a new QuadRenderer\n   *\n   * @param options Parameters for this QuadRenderer\n   */\n  constructor(options) {\n    this._width = options.width;\n    this._height = options.height;\n    this._type = options.type;\n    this._colorSpace = options.colorSpace;\n    const rtOptions = {\n      // fixed options\n      format: RGBAFormat,\n      depthBuffer: false,\n      stencilBuffer: false,\n      // user options\n      type: this._type,\n      // set in class property\n      colorSpace: this._colorSpace,\n      // set in class property\n      anisotropy: options.renderTargetOptions?.anisotropy !== undefined ? options.renderTargetOptions?.anisotropy : 1,\n      generateMipmaps: options.renderTargetOptions?.generateMipmaps !== undefined ? options.renderTargetOptions?.generateMipmaps : false,\n      magFilter: options.renderTargetOptions?.magFilter !== undefined ? options.renderTargetOptions?.magFilter : LinearFilter,\n      minFilter: options.renderTargetOptions?.minFilter !== undefined ? options.renderTargetOptions?.minFilter : LinearFilter,\n      samples: options.renderTargetOptions?.samples !== undefined ? options.renderTargetOptions?.samples : undefined,\n      wrapS: options.renderTargetOptions?.wrapS !== undefined ? options.renderTargetOptions?.wrapS : ClampToEdgeWrapping,\n      wrapT: options.renderTargetOptions?.wrapT !== undefined ? options.renderTargetOptions?.wrapT : ClampToEdgeWrapping\n    };\n    this._material = options.material;\n    if (options.renderer) {\n      this._renderer = options.renderer;\n    } else {\n      this._renderer = QuadRenderer.instantiateRenderer();\n      this._rendererIsDisposable = true;\n    }\n    this._scene = new Scene();\n    this._camera = new OrthographicCamera();\n    this._camera.position.set(0, 0, 10);\n    this._camera.left = -0.5;\n    this._camera.right = 0.5;\n    this._camera.top = 0.5;\n    this._camera.bottom = -0.5;\n    this._camera.updateProjectionMatrix();\n    if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n      let alternativeType;\n      switch (this._type) {\n        case HalfFloatType:\n          alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n          break;\n      }\n      if (alternativeType !== undefined) {\n        console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n        this._type = alternativeType;\n      } else {\n        this._supportsReadPixels = false;\n        console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n      }\n    }\n    this._quad = new Mesh(new PlaneGeometry(), this._material);\n    this._quad.geometry.computeBoundingBox();\n    this._scene.add(this._quad);\n    this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n    this._renderTarget.texture.mapping = options.renderTargetOptions?.mapping !== undefined ? options.renderTargetOptions?.mapping : UVMapping;\n  }\n  /**\n   * Instantiates a temporary renderer\n   *\n   * @returns\n   */\n  static instantiateRenderer() {\n    const renderer = new WebGLRenderer();\n    renderer.setSize(128, 128);\n    // renderer.outputColorSpace = SRGBColorSpace\n    // renderer.toneMapping = LinearToneMapping\n    // renderer.debug.checkShaderErrors = false\n    // this._rendererIsDisposable = true\n    return renderer;\n  }\n  /**\n   * Renders the input texture using the specified material\n   */\n  render = () => {\n    this._renderer.setRenderTarget(this._renderTarget);\n    try {\n      this._renderer.render(this._scene, this._camera);\n    } catch (e) {\n      this._renderer.setRenderTarget(null);\n      throw e;\n    }\n    this._renderer.setRenderTarget(null);\n  };\n  /**\n   * Obtains a Buffer containing the rendered texture.\n   *\n   * @throws Error if the browser cannot read pixels from this RenderTarget type.\n   * @returns a TypedArray containing RGBA values from this renderer\n   */\n  toArray() {\n    if (!this._supportsReadPixels) throw new Error('Can\\'t read pixels in this browser');\n    const out = getBufferForType(this._type, this._width, this._height);\n    this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n    return out;\n  }\n  /**\n   * Performs a readPixel operation in the renderTarget\n   * and returns a DataTexture containing the read data\n   *\n   * @param options options\n   * @returns\n   */\n  toDataTexture(options) {\n    const returnValue = new DataTexture(\n    // fixed values\n    this.toArray(), this.width, this.height, RGBAFormat, this._type,\n    // user values\n    options?.mapping || UVMapping, options?.wrapS || ClampToEdgeWrapping, options?.wrapT || ClampToEdgeWrapping, options?.magFilter || LinearFilter, options?.minFilter || LinearFilter, options?.anisotropy || 1,\n    // fixed value\n    LinearSRGBColorSpace);\n    // set this afterwards, we can't set it in constructor\n    returnValue.generateMipmaps = options?.generateMipmaps !== undefined ? options?.generateMipmaps : false;\n    return returnValue;\n  }\n  /**\n   * If using a disposable renderer, it will dispose it.\n   */\n  disposeOnDemandRenderer() {\n    this._renderer.setRenderTarget(null);\n    if (this._rendererIsDisposable) {\n      this._renderer.dispose();\n      this._renderer.forceContextLoss();\n    }\n  }\n  /**\n   * Will dispose of **all** assets used by this renderer.\n   *\n   *\n   * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n   * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n   * or are otherwise done with it.\n   *\n   * @example\n   * ```js\n   * const loader = new HDRJPGLoader(renderer)\n   * const result = await loader.loadAsync('gainmap.jpeg')\n   * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n   * // DO NOT dispose the renderTarget here,\n   * // it is used directly in the material\n   * result.dispose()\n   * ```\n   *\n   * @example\n   * ```js\n   * const loader = new HDRJPGLoader(renderer)\n   * const pmremGenerator = new PMREMGenerator( renderer );\n   * const result = await loader.loadAsync('gainmap.jpeg')\n   * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n   * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n   * // renderTarget can be disposed here\n   * // because it was used to generate a PMREM texture\n   * result.dispose(true)\n   * ```\n   */\n  dispose(disposeRenderTarget) {\n    this.disposeOnDemandRenderer();\n    if (disposeRenderTarget) {\n      this.renderTarget.dispose();\n    }\n    // dispose shader material texture uniforms\n    if (this.material instanceof ShaderMaterial) {\n      Object.values(this.material.uniforms).forEach(v => {\n        if (v.value instanceof Texture) v.value.dispose();\n      });\n    }\n    // dispose other material properties\n    Object.values(this.material).forEach(value => {\n      if (value instanceof Texture) value.dispose();\n    });\n    this.material.dispose();\n    this._quad.geometry.dispose();\n  }\n  /**\n   * Width of the texture\n   */\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n    this._renderTarget.setSize(this._width, this._height);\n  }\n  /**\n   * Height of the texture\n   */\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n    this._renderTarget.setSize(this._width, this._height);\n  }\n  /**\n   * The renderer used\n   */\n  get renderer() {\n    return this._renderer;\n  }\n  /**\n   * The `WebGLRenderTarget` used.\n   */\n  get renderTarget() {\n    return this._renderTarget;\n  }\n  set renderTarget(value) {\n    this._renderTarget = value;\n    this._width = value.width;\n    this._height = value.height;\n    // this._type = value.texture.type\n  }\n  /**\n   * The `Material` used.\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   *\n   */\n  get type() {\n    return this._type;\n  }\n  get colorSpace() {\n    return this._colorSpace;\n  }\n}\nexport { QuadRenderer as Q };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}